<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Linux 简介]]></title>
      <url>http://hamstersi.github.io/2017/08/Linux-%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Linux-系统目录结构"><a href="#Linux-系统目录结构" class="headerlink" title="Linux 系统目录结构"></a>Linux 系统目录结构</h1><p>/bin bin 是 Binary 的缩写。这个目录存放着最经常使用的命令。</p><p>/boot 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p><p>/dev dev 是 Device(设备)的缩写。该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p><p>/etc 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p><p>/home 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</p><p>/lib 这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p><a id="more"></a><p>/lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><p>/media linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。</p><p>/mnt 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p><p>/opt 这是给主机额外安装软件所摆放的目录。比如你安装一个 ORACLE 数据库则就可以放到这个目录下。默认是空的。</p><p>/proc 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 ping 命令，使别人无法 ping 你的机器：</p><p>echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all。</p><p>/root 该目录为系统管理员，也称作超级权限者的用户主目录。</p><p>/sbin s 就是 Super User 的意思，这里存放的是系统管理员使用的系统管理程序。</p><p>/selinux 这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 Windows 的防火墙，但是这套机制比较复杂，这个目录就是存放 selinux 相关的文件的。</p><p>/srv 该目录存放一些服务启动之后需要提取的数据。</p><p>/sys 这是 linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs ，sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统种被创建。</p><p>/tmp 这个目录是用来存放一些临时文件的。</p><p>/usr 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows 下的 program files目录。</p><p>/usr/bin：系统用户使用的应用程序。</p><p>/usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。</p><p>/usr/src：内核源代码默认的放置目录。</p><p>/var 这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</p><p>在 linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。/etc： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。/bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除 root 外的通用户），而 /sbin, /usr/sbin 则是给 root 使用的指令。 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。</p><h1 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h1><table><thead><tr><th>快捷键</th><th>简介</th></tr></thead><tbody><tr><td>Tab</td><td>自动补全</td></tr><tr><td>Ctrl + D</td><td>退出当前终端，也可以输入 exit</td></tr><tr><td>Ctrl + Z</td><td>暂停当前进程，比如你正运行一个命令，突然觉得有点问题想暂停一下，就可以使用这个快捷键。暂停后可用 fg 恢复</td></tr><tr><td>Ctrl + L</td><td>清屏，使光标移动到第一行</td></tr></tbody></table><h1 id="Linux-文件目录管理"><a href="#Linux-文件目录管理" class="headerlink" title="Linux 文件目录管理"></a>Linux 文件目录管理</h1><h2 id="环境变量PATH"><a href="#环境变量PATH" class="headerlink" title="环境变量PATH"></a>环境变量PATH</h2><p>将 /root 路径加入 PATH 当中：PATH=”$PATH”:/root</p><p>LIBRARY_PATH环境变量用于在<strong>程序编译期间</strong>查找动态链接库时指定查找共享库的路径，例如，指定gcc编译需要用到的动态链接库的目录。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export LIBRARY_PATH=LIBDIR1:LIBDIR2:$LIBRARY_PATH</div></pre></td></tr></table></figure><p>LD_LIBRARY_PATH环境变量用于在<strong>程序加载运行期间</strong>查找动态链接库时指定除了系统默认路径之外的其他路径，注意，LD_LIBRARY_PATH中指定的路径会在系统默认路径之前进行查找。设置方法如下（其中，LIBDIR1和LIBDIR2为两个库目录）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export LD_LIBRARY_PATH=LIBDIR1:LIBDIR2:$LD_LIBRARY_PATH</div></pre></td></tr></table></figure><p>举个例子，我们开发一个程序，经常会需要使用某个或某些动态链接库，为了保证程序的可移植性，可以先将这些编译好的动态链接库放在自己指定的目录下，然后按照上述方式将这些目录加入到LD_LIBRARY_PATH环境变量中，这样自己的程序就可以动态链接后加载库文件运行了。</p><p><strong>区别与使用：</strong></p><p>开发时，设置LIBRARY_PATH，以便gcc能够找到编译时需要的动态链接库。</p><p>发布时，设置LD_LIBRARY_PATH，以便程序加载运行时能够自动找到需要的动态链接库。</p><h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>用ls –l 查看当前目录下的文件时，共显示了9列内容（用空格划分列），都代表了什么含义呢？</p><p>第1列，包含的东西有该文件类型和所属主、所属组以及其他用户对该文件的权限。第一列共10位。其中第一位用来描述该文件的类型。上例中，我们看到的类型有”d”, “-“ ，其实除了这两种外还有”l”, “b”, “c”,”s”等。</p><p>d表示该文件为目录；</p><p>-表示该文件为普通文件；</p><p>l表示该文件为连接文件（linux file），上边提到的软连接即为该类型；</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_81.png.jpg" alt="6_81.png.jpg"></p><p>b表示该文件为块设备文件，比如磁盘分区</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_82.png.jpg" alt="6_82.png.jpg"></p><p>c表示该文件为串行端口设备，例如键盘、鼠标。</p><p>s表示该文件为套接字文件（socket），用于进程间通信。</p><p>后边的9位，每三个为一组。均为rwx 三个参数的组合。其中r 代表可读，w代表可写，x代表可执行。前三位为所属主（user）的权限，中间三位为所属组（group）的权限，最后三位为其他非本群组（others）的权限。下面拿一个具体的例子来述说一下。</p><p>一个文件的属性为-rwxr-xr– ，它代表的意思是，该文件为普通文件，文件拥有者可读可写可执行，文件所属组对其可读不可写可执行，其他用户对其只可读。</p><p>对于一个目录来讲，打开这个目录即为执行这个目录，所以任何一个目录必须要有x权限才能打开并查看该目录。例如一个目录的属性为 drwxr–r– 其所属主为root，那么除了root外的其他用户是不能打开这个目录的。</p><p>第2列，表示为连接占用的节点（inode），若为目录时，通常与该目录地下还有多少目录有关系，关于连接（link）在以后章节详细介绍。</p><p>第3列，表示该文件的所属主。</p><p>第4列，表示该文件的所属组。</p><p>第5列，表示该文件的大小。</p><p>第6列、第7列和第8列为该文件的创建日期或者最近的修改日期，分别为月份日期以及时间。</p><p>第9列，文件名。如果前面有一个. 则表示该文件为隐藏文件。</p><h2 id="更改文件的权限"><a href="#更改文件的权限" class="headerlink" title="更改文件的权限"></a>更改文件的权限</h2><p>更改文件的权限，也就是更改所属主、所属组以及他们对应的读写执行权限。</p><p>1）<strong>更改所属组</strong> <strong>chgrp</strong></p><p>语法：chgrp [组名][文件名]</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_83.png.jpg" alt="6_83.png.jpg"></p><p>这里用到了groupadd 命令，其含义即增加一个用户组。该命令在以后章节中做详细介绍，你只要知道它是用来增加用户组的即可。</p><p>2）<strong>更改文件的所属主</strong> <strong>chown</strong></p><p>语法：chown [ -R ] 账户名文件名</p><p>chown [ -R ] 账户名：组名文件名</p><p>这里的-R选项只作用于目录，作用是级联更改，即不仅更改当前目录，连目录里的目录或者文件全部更改。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_84.png.jpg" alt="6_84.png.jpg"></p><p>useradd 是增加一个账户，以后会详细介绍。上例中，首先建立一个目录test，然后在test目录下创建一个普通文件test2，因为是以root的身份创建的目录和文件，所以所属主以及所属组都是root。chown user1 test 这使test的目录所属主由root变为了user1 ，然后test目录下的test2文件所属主以及所属组还是root。接着 chown –R user1:testgroup test 这样把test连同test目录下的test2 的所属主以及所属组都改变了。</p><p>3）<strong>改变用户对文件的读写执行权限</strong> <strong>chmod</strong></p><p>在linux中为了方便更改这些权限，linux使用数字去代替rwx ，具体规则为r: 4 w:2 x:1 -:0 举个例子，-rwxrwx—用数字表示就是 770，具体是这样来的：</p><p>rwx = 4+2+1=7; rwx= 4+2+1=7; — = 0+0+0=0</p><p>chmod 语法： chmod [-R] xyz 文件名（这里的xyz，表示数字）</p><p>-R 选项作用同chown，级联更改。</p><p>值得提一下的是，在linux系统中，默认一个目录的权限为 755，而一个文件的默认权限为644.</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_85.png.jpg" alt="6_85.png.jpg"></p><p>如果你创建了一个目录，而该目录不想让其他人看到内容，则只需设置成 rwxr—– (740) 即可。</p><p>chmod 还支持使用rwx的方式来设置权限。！从之前的介绍中我们可以发现，基本上就九个属性分别是(1)user (2)group (3)others 三群啦！那么我们就可以藉由 u, g, o 来代表三群的属性！此外， a 则代表 all 亦即全部的三群！那么读写的属性就可以写成了 r, w, x！也就是可以使用底下的方式来看：</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_86.png.jpg" alt="6_86.png.jpg"></p><p>现在我想把一个文件设置成这样的权限 rwxr-xr-x (755)，使用这种方式改变权限的命令为</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_87.png.jpg" alt="6_87.png.jpg"></p><p>另外还可以针对u, g, o, a增加或者减少某个权限（读，写，执行），例如</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_88.png.jpg" alt="6_88.png.jpg"></p><p>另外linux下还有两个比较特殊的权限s和t，请点击<a href="">linux下文件的特殊权限s和t</a></p><p><strong>umask</strong></p><p>上边也提到了默认情况下，目录权限值为766，普通文件权限值为644。那么这个值是由谁规定呢？追究其原因就涉及到了umask。</p><p>umask语法： umask xxx （这里的xxx代表三个数字）</p><p>查看umask值只要输入umask然后回车。 umask预设是0022，其代表什么含义？先看一下下面的规则：</p><p>1）若用户建立为普通文件，则预设“没有可执行权限”，只有rw两个权限。最大为666（-rw-rw-rw-）</p><p>2）若用户建立为目录，则预设所有权限均开放，即777（drwxrwxrwx）</p><p>umask数值代表的含义为，上边两条规则中的默认值（文件为666，目录为777）需要减掉的权限。所以目录的权限为(rwxrwxrwx) – (—-w–w-) = (rwxr-xr-x)，普通文件的权限为(rw-rw-rw-) – (—-w–w-) = (rw-r–r–)。umask的值是可以自定义的，比如设定umask 为 002，你再创建目录或者文件时，默认权限分别为(rwxrwxrwx) – (——-w-) = (rwxrwxr-x)和(rw-rw-rw-) – (——-w-) = (rw-rw-r–)。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_89.png.jpg" alt="6_89.png.jpg"></p><p>umask 可以在/etc/bashrc里面更改，预设情况下，root的umask为022，而一般使用者则为002，因为可写的权限非常重要，因此预设会去掉写权限。</p><h2 id="搜索文件"><a href="#搜索文件" class="headerlink" title="搜索文件"></a>搜索文件</h2><p><strong>which</strong>用来查找可执行文件的绝对路径。需要注意的一点是，which只能用来查找PATH环境变量中出现的路径下的可执行文件。这个命令用的也是蛮多的，有时候我们不知道某个命令的绝对路径，which一下很容易就知道了。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_93.png.jpg" alt="6_93.png.jpg"></p><p>当查找的文件在PATH变量中并没有时，就会报错。<strong>whereis</strong> 通过预先生成的一个文件列表库去查找跟给出的文件名相关的文件。</p><p>语法： whereis [-bmsu][文件名称]</p><p>-b：只找binary 文件</p><p>-m：只找在说明文件manual路径下的文件</p><p>-s：只找source来源文件</p><p>-u：没有说明档的文件</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_94.png.jpg" alt="6_94.png.jpg"></p><p><strong>locate</strong>类似于whereis，也是通过查找预先生成的文件列表库来告诉用户要查找的文件在哪里。后边直接跟文件名。如果你的linux没有这个命令，请安装软件包 mlocate ，这个软件包在你的系统安装盘里，后缀名是RPM，随后介绍的find命令会告诉你如何查找这个包。如果你装的CentOS你可以使用这个命令来安装 yum install –y mlocate 。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_95.png.jpg" alt="6_95.png.jpg"></p><p>这是因为系统还没有生成那个文件列表库。你可以使用updatedb 命令立即生成（更新）这个库。如果你的服务器上正跑着重要的业务，那么你最好不要去运行这个命令，因为一旦运行，服务器的压力会变大。这个数据库默认情况下每周更新一次。所以你用locate命令去搜索一个文件，正好是在两次更新时间段内，那你肯定是得不到结果的。你可以到/etc/updated.conf 去配置这个数据库生成（更新）的规则。locate命令笔者用的也并不多，所以你只要明白有这么一个东西即可。你用到时再去深究其用法吧。</p><p><strong>find</strong> 语法： find [路径][参数]</p><p>-atime +n ：访问或执行时间大于n天的文件</p><p>-ctime +n ：写入、更改inode属性（例如更改所有者、权限或者连接）时间大于n天的文件</p><p>-mtime +n ：写入时间大于n天的文件</p><p>看到这里，你对这三个time是不是有些晕了，那笔者就先给你介绍一下这三个time属性。</p><p>文件的 Access time，atime 是在读取文件或者执行文件时更改的。文件的 Modified time，mtime 是在写入文件时随文件内容的更改而更改的。文件的 Create time，ctime 是在写入文件、更改所有者、权限或链接设置时随 inode 的内容更改而更改的。 因此，更改文件的内容即会更改 mtime 和 ctime，但是文件的 ctime 可能会在 mtime 未发生任何变化时更改，例如，更改了文件的权限，但是文件内容没有变化。 如何获得一个文件的atime mtime 以及ctime ？</p><p>ls -l 命令可用来列出文件的 atime、ctime 和 mtime。</p><p>ls -lc filename 列出文件的 ctime</p><p>ls -lu filename 列出文件的 atime</p><p>ls -l filename 列出文件的 mtime</p><p>atime不一定在访问文件之后被修改，因为：使用ext3文件系统的时候，如果在mount的时候使用了noatime参数那么就不会更新atime的信息。而这是加了 noatime 取消了, 不代表真实情況。反正, 這三個 time stamp 都放在 inode 中。若 mtime, atime 修改inode 就一定會改, 既然 inode 改了, 那 ctime 也就跟著要改了。</p><p>继续讲find常用的参数。</p><p>-name filename 直接查找该文件名的文件，这个使用最多了。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_96.png.jpg" alt="6_96.png.jpg"></p><p>-type type ：通过文件类型查找。文件类型在前面部分已经简单介绍过，相信你已经大体上了解了。type 包含了 f, b, c, d, l, s 等等。后续的内容还会介绍文件类型的。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_97.png.jpg" alt="6_97.png.jpg"></p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>linux的文件系统格式为Ext2，或者Ext3 。早期的linux使用Ext2格式，目前的linux都使用了Ext3。Ext3文件系统是直接从Ext2文件系统发展而来，Ext3文件系统带有日志功能，可以跟踪记录文件系统的变化，并将变化内容写入日志，写操作首先是对日志记录文件进行操作，若整个写操作由于某种原因 (如系统掉电) 而中断，系统重启时，会根据日志记录来恢复中断前的写操作，而且这个过程费时极短。</p><p>Linux文件系统在windows中是不能识别的，但是在linux系统中你可以挂载的windows的文件系统，linux目前支持MS-DOS，VFAT，FAT，BSD等格式。Ext3文件系统为Redhat/CentOS默认使用的文件系统，除了Ext3文件系统外，有些linux发行版例如SuSE默认的文件系统为reiserFS ，Ext3 独特的优点就是易于转换，很容易在 Ext2 和 Ext3 之间相互转换，而具有良好的兼容性，其它优点reiserFS 都有，而且还比它做得更好。如高效的磁盘空间利用和独特的搜寻方式都是Ext3 所不具备的，速度上它也不能和 reiserFS相媲美，在实际使用过程中，reiserFS 也更加安全高效.</p><p>##文件类型</p><p>1）正规文件（regular file）：就是一般类型的文件，当用ls –l 查看某个目录时，第一个属性为”-“的文件就是正规文件，或者叫普通文件。正规文件又可分成纯文字文件（ascii）和二进制文件（binary）。纯文本文件是可以通过cat, more, less等工具直接查看内容的，而二进制文件并不能。例如我们用的命令/bin/ls 这就是一个二进制文件。</p><p>2）目录（directory）：这个很容易理解，就是目录，跟windows下的文件夹一个意思，只不过在linux中我们不叫文件夹，而是叫做目录。ls –l 查看第一个属性为”d”。</p><p>3）连接档（link）：ls –l 查看第一个属性为 “l”，类似windows下的快捷方式。这种文件在linux中很常见，而且笔者在日常的系统运维工作中用的很多，所以你要特意留意一下这种类型的文件。在后续章节笔者会介绍。</p><p>4）设备档（device）：与系统周边相关的一些档案，通常都集中在 /dev 这个目录之下！通常又分为两种：区块(block) 设备档：就是一些储存数据，以提供系统存取的接口设备，简单的说就是硬盘啦！例如你的一号硬盘的代码是/dev/hda1 等等的档案啦！第一个属性为 “ b “；字符 (character) 设备档：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！第一个属性为 “ c “。</p><h2 id="ln-建立连接档"><a href="#ln-建立连接档" class="headerlink" title="ln 建立连接档"></a>ln 建立连接档</h2><p>连接档分为两种，硬连接（hard link）和软连接（symbolic link）。</p><p><strong>Hard Links：</strong>上面内容中说过，当系统要读取一个文件时，就会先去读inode table，然后再去根据inode中的信息到块区域去将数据取出来。而hard link 是直接再建立一个inode连接到文件放置的块区域。也就是说，进行hard link的时候实际上该文件内容没有任何变化，只是增加了一个指到这个文件的inode，不过这样一来就会有个问题，因为增加的inode会连接到块区域，而目录本身仅仅消耗inode而已，那么hard link就不能连接目录了。请你记住，hard link 有两个限制：1 不能跨文件系统，因为不通的文件系统有不同的inode table； 2 不能连接目录。</p><p><strong>Symbolic Links：</strong>跟hard link不同，这个是建立一个独立的文件，而这个文件的作用是当读取这个连接文件时，它会把读取的行为转发到该文件所link的文件上。这样讲，也许比较绕口，那么就来举一个例子。现在有文件a，我们做了一个软连接文件b（只是一个连接文件，非常小），b指向了文件a。当读取b时，那么b就会把读取的动作转发到a上，这样就读取到了文件a。所以，当你删除文件a时，文件b并不会被删除，但是再读取b时，会提示无法打开文件。而，当你删除b时，a是不会有任何影响的。</p><p>ln 语法： ln [-s][来源文件] [目的文件]</p><p>ln 常用的选项就一个-s ，如果不加就是建立硬连接，加上就建立软连接。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_100.png.jpg" alt="6_100.png.jpg"></p><p>在建立硬连接前后，123目录所占空间大小并没有改变。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_101.png.jpg" alt="6_101.png.jpg"></p><p>当把源文件删除后，空间仍旧没有变化。说明了删除一个文件其实只是删除了inode信息。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_102.png.jpg" alt="6_102.png.jpg"></p><p>不能创建目录的硬连接。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_103.png.jpg" alt="6_103.png.jpg"></p><p>建立软连接后，456目录增加了4k</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_104.png.jpg" alt="6_104.png.jpg"></p><p>删除源文件后会提示“没有这个文件”的错误。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_105.png.jpg" alt="6_105.png.jpg"></p><p>目录是可以软连接的。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/6_106.png.jpg" alt="6_106.png.jpg"></p><p>删除软连接对源文件没有任何影响。</p><h1 id="系统用户及用户组"><a href="#系统用户及用户组" class="headerlink" title="系统用户及用户组"></a>系统用户及用户组</h1><p><strong>【**</strong>认识<strong><strong>/etc/passwd</strong></strong>和<strong>**/etc/shadow】</strong></p><p>这两个文件可以说是linux系统中最重要的文件之一。如果没有这两个文件或者这两个文件出问题，则你是无法正常登录linux系统的。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_1.png.jpg" alt="7_1.png.jpg"></p><p>/etc/passwd由’:’分割成7个字段，每个字段的具体含义是：</p><p>1）用户名（如第一行中的root就是用户名），代表用户账号的字符串。用户名字符可以是大小写字母、数字、减号（不能出现在首位）、点以及下划线，其他字符不合法。虽然用户名中可以出现点，但不建议使用，尤其是首位为点时，另外减号也不建议使用，因为容易造成混淆。</p><p>2）存放的就是该账号的口令，为什么是’x’呢？早期的unix系统口令确实是存放在这里，但基于安全因素，后来就将其存放到/etc/shadow中了，在这里只用一个’x’代替。</p><p>3）这个数字代表用户标识号，也叫做uid。系统识别用户身份就是通过这个数字来的，0就是root，也就是说你可以修改test用户的uid为0，那么系统会认为root和test为同一个账户。通常uid的取值范围是0~65535，0是超级用户（root）的标识号，1~499由系统保留，作为管理账号，普通用户的标识号从500开始，如果我们自定义建立一个普通用户，你会看到该账户的标识号是大于或等于500的。</p><p>4）表示组标识号，也叫做gid。这个字段对应着/etc/group 中的一条记录，其实/etc/group和/etc/passwd基本上类似。</p><p>5）注释说明，该字段没有实际意义，通常记录该用户的一些属性，例如姓名、电话、地址等等。不过，当你使用finger的功能时就会显示这些信息的（稍后做介绍）。</p><p>6）用户的家目录，当用户登录时就处在这个目录下。root的家目录是/root，普通用户的家目录则为/home/username，这个字段是可以自定义的，比如你建立一个普通用户test1，要想让test1的家目录在/data目录下，只要修改/etc/passwd文件中test1那行中的该字段为/data即可。</p><p>7）shell，用户登录后要启动一个进程，用来将用户下达的指令传给内核，这就是shell。Linux的shell有很多种sh, csh, ksh, tcsh, bash等，而Redhat/CentOS的shell就是bash。查看/etc/passwd文件，该字段中除了/bin/bash外还有/sbin/nologin比较多，它表示不允许该账号登录。如果你想建立一个账号不让他登录，那么就可以把该字段改成/sbin/nologin，默认是/bin/bash。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_12.png.jpg" alt="7_12.png.jpg"></p><p>再来看看/etc/shadow这个文件，和/etc/passwd类似，用”:”分割成9个字段。</p><p>1）用户名，跟/etc/passwd对应。</p><p>2）用户密码，这个才是该账号的真正的密码，不过这个密码已经加密过了，但是有些黑客还是能够解密的。所以为了安全，该文件属性设置为600，只允许root读写。</p><p>3）上次更改密码的日期，这个数字是这样计算得来的，距离1970年1月1日到上次更改密码的日期，例如上次更改密码的日期为2012年1月1日，则这个值就是365*（2012-1970）+1=15331。</p><p>4）要过多少天才可以更改密码，默认是0，即不限制。</p><p>5）密码多少天后到期。即在多少天内必须更改密码，例如这里设置成30，则30天内必须更改一次密码，否则将不能登录系统，默认是99999，可以理解为永远不需要改。</p><p>6）密码到期前的警告期限，若这个值设置成7，则表示当7天后密码过期时，系统就发出警告告诉用户，提醒用户他的密码将在7天后到期。</p><p>7）账号失效期限。你可以这样理解，如果设置这个值为3，则表示：密码已经到期，然而用户并没有在到期前修改密码，那么再过3天，则这个账号就失效了，即锁定了。</p><p>8）账号的生命周期，跟第三段一样，是按距离1970年1月1日多少天算的。它表示的含义是，账号在这个日期前可以使用，到期后账号作废。</p><p>9）作为保留用的，没有什么意义。</p><p><strong>【**</strong>新增<strong><strong>/</strong></strong>删除用户和用户组<strong>**】</strong></p><p>a. 新增一个组 groupadd [-g GID] groupname</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_13.png.jpg" alt="7_13.png.jpg"></p><p>不加-g 则按照系统默认的gid创建组，跟用户一样，gid也是从500开始的</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_14.png.jpg" alt="7_14.png.jpg"></p><p>-g选项可以自定义gid</p><p>b. 删除组 gropudel groupname</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_15.png.jpg" alt="7_15.png.jpg"></p><p>没有特殊选项。</p><p>c. 增加用户 useradd [-u UID] [-g GID] [-d HOME] [-M] [-s]</p><p>-u 自定义UID</p><p>-g 使其属于已经存在的某个GID</p><p>-d 自定义用户的家目录</p><p>-M 不建立家目录</p><p>-s 自定义shell</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_16.png.jpg" alt="7_16.png.jpg"></p><p>你会发现，创建test11时，加上了-M选项后，在/etc/passwd文件中test11那行的第六字段依然有/home/test11，可是ls查看该目录时，会提示该目录不存在。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_17.png.jpg" alt="7_17.png.jpg"></p><p>-M选项的作用就是不创建用户的家目录。</p><p>-d. 删除用户 userdel [-r] username</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_18.png.jpg" alt="7_18.png.jpg"></p><p>-r 选项的作用是删除用户时，连同用户的家目录一起删除。</p><p><strong>【chfn</strong> <strong>更改用户的**</strong>finger<strong> </strong>（不常用）<strong>**】</strong></p><p>前面内容中提到了findger，即在/etc/passwd文件中的第5个字段中所显示的信息，那么如何去设定这个信息呢？</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_19.png.jpg" alt="7_19.png.jpg"></p><p>就是chfn这个命令了。修改完后，就会在/etc/passwd文件中的test的那一行第五个字段中看到相关信息了，默认是空的。</p><p><strong>【**</strong>创建<strong><strong>/</strong></strong>修改一个用户的密码<strong> </strong>“passwd [username]”】**</p><p>等创建完账户后，默认是没有设置密码的，虽然没有密码，但该账户同样登录不了系统。只有设置好密码后方可登录系统。</p><p>为用户创建密码时，为了安全起见，请尽量设置复杂一些。你可以按照这样的规则来设置密码：a. 长度大于10个字符；b.密码中包含大小写字母数字以及特殊字符（*&amp;等）；c. 不规则性（不要出现root, happy, love, linux, 123456, 111111等等单词或者数字）；d. 不要带有自己名字、公司名字、自己电话、自己生日等。</p><p><img src="http://wiki.jikexueyuan.com/project/linux/images/7_20.png.jpg" alt="7_20.png.jpg"></p><p>passwd 后面不跟用户名则是更改当前用户的密码，当前用户为root，所以此时修改的是root的密码，后面跟test则修改的是test的密码。</p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[VIM&VI Cheatsheet]]></title>
      <url>http://hamstersi.github.io/2017/08/VIM-VI-Cheatsheet/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="VIM-VI简介"><a href="#VIM-VI简介" class="headerlink" title="VIM/VI简介"></a>VIM/VI简介</h1><p>Vim 编辑器是功能强大的跨平台文本文件编辑工具，继承自Unix系统的Vi编辑器，支持Linux/Mac OS X/Windows系统，利用它可以建立、修改文本文件。进入Vim编辑程序，可以在终端输入下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$vim [filename]</div></pre></td></tr></table></figure><p>其中<code>filename</code>是要编辑器的文件的路径名。如果文件不存在，它将为你建立一个新文件。Vim编辑程序有三种操作模式，分别称为 <strong>编辑模式</strong>、<strong>插入模式</strong> 和 <strong>命令模式</strong>，当运行Vim时，首先进入编辑模式。</p><p><strong>一般模式：</strong>当你vim filename 编辑一个文件时，一进入该文件就是一般模式了。在这个模式下，你可以做的操作有，上下移动光标；删除某个字符；删除某行；复制、粘贴一行或者多行。</p><p><strong>编辑模式：</strong>一般模式下，是不可以修改某一个字符的，只能到编辑模式了。从一般模式进入编辑模式，只需你按一个键即可（i,I,a,A,o,O,r,R）。当进入编辑模式时，会在屏幕的最下一行出现“INSERT或REPLACE”的字样。从编辑模式回到一般模式只需要按一下键盘左上方的ESC键即可。</p><p><strong>命令模式：</strong>在一般模式下，输入”:”或者”/”即可进入命令模式。在该模式下，你可以搜索某个字符或者字符串，也可以保存、替换、退出、显示行号等等。</p><a id="more"></a><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><table><thead><tr><th>移动光标</th><th>简介</th></tr></thead><tbody><tr><td>h或向左方向键</td><td>光标向左移动一个字符</td></tr><tr><td>j或者向下方向键</td><td>光标向下移动一个字符</td></tr><tr><td>K或者向上方向键</td><td>光标向上移动一个字符</td></tr><tr><td>l或者向右方向键</td><td>光标向右移动一个字符</td></tr><tr><td>Ctrl + f 或者pageUP键</td><td>屏幕向前移动一页</td></tr><tr><td>Ctrl + b 或者pageDOWN键</td><td>屏幕向后移动一页</td></tr><tr><td>Ctrl + d</td><td>屏幕向前移动半页</td></tr><tr><td>Ctrl + u</td><td>屏幕向后移动半页</td></tr><tr><td>+</td><td>光标移动到非空格符的下一列</td></tr><tr><td>-</td><td>光标移动到非空格符的上一列</td></tr><tr><td>n空格（n是数字）</td><td>按下数字n然后按空格，则光标向右移动n个字符，如果该行字符数小于n，则光标继续从下行开始向右移动，一直到n</td></tr><tr><td>0（数字0）或者Shift+6</td><td>移动到本行行首</td></tr><tr><td>Shift+4</td><td>即’$’移动到本行行尾</td></tr><tr><td>H</td><td>光标移动到当前屏幕的最顶行</td></tr><tr><td>M</td><td>光标移动到当前屏幕的中央那一行</td></tr><tr><td>L</td><td>光标移动到当前屏幕的最底行</td></tr><tr><td>G</td><td>光标移动到文本的最末行</td></tr><tr><td>nG（n是数字）</td><td>移动到该文本的第n行</td></tr><tr><td>gg</td><td>移动带该文本的首行</td></tr><tr><td>n回车（n是数字）</td><td>光标向下移动n行</td></tr></tbody></table><table><thead><tr><th>查找替换</th><th>简介</th></tr></thead><tbody><tr><td>/word</td><td>向光标之后寻找一个字符串名为word的字符串，当找到第一个word后，按”n”继续搜后一个</td></tr><tr><td>?word</td><td>想光标之前寻找一个字符串名为word的字符串，当找到第一个word后，按”n”继续搜前一个</td></tr><tr><td>:n1,n2s/word1/word2/g</td><td>在n1和n2行间查找word1这个字符串并替换为word2，你也可以把”/”换成”#”</td></tr><tr><td>:1,$s/word1/word2/g</td><td>从第一行到最末行，查找word1并替换成word2</td></tr><tr><td>:1,$s/word1/word2/gc</td><td>加上c的作用是，在替换前需要用户确认</td></tr></tbody></table><table><thead><tr><th>删除复制粘贴</th><th>简介</th></tr></thead><tbody><tr><td>x,X</td><td>x为向后删除一个字符，X为向前删除一个字符</td></tr><tr><td>nx（n为数字）</td><td>向后删除n个字符</td></tr><tr><td>dd</td><td>删除光标所在的那一行</td></tr><tr><td>ndd（n为数字）</td><td>删除光标所在的向下n行</td></tr><tr><td>d1G</td><td>删除光标所在行到第一行的所有数据</td></tr><tr><td>dG</td><td>删除光标所在行到末行的所有数据</td></tr><tr><td>yy</td><td>复制光标所在的那行</td></tr><tr><td>nyy（n为数字）</td><td>复制从光标所在行起向下n行</td></tr><tr><td>p,P</td><td>p复制的数据从光标下一行粘贴，P则从光标上一行粘贴</td></tr><tr><td>y1G</td><td>复制光标所在行到第一行的所有数据</td></tr><tr><td>yG</td><td>复制光标所在行到末行的所有数据</td></tr><tr><td>J</td><td>讲光标所在行与下一行的数据结合成同一行</td></tr><tr><td>u</td><td>还原过去的操作</td></tr></tbody></table><table><thead><tr><th>编辑模式</th><th>简介</th></tr></thead><tbody><tr><td>i</td><td>在当前字符前插入字符</td></tr><tr><td>I</td><td>在当前行行首插入字符</td></tr><tr><td>a</td><td>在当前字符后插入字符</td></tr><tr><td>A</td><td>在当前行行末插入字符</td></tr><tr><td>o</td><td>在当前行下插入新的一行</td></tr><tr><td>O</td><td>在当前行上插入新的一行</td></tr><tr><td>r</td><td>替换光标所在的字符，只替换一次</td></tr><tr><td>R</td><td>一直替换光标所在的字符，一直到按下ESC</td></tr></tbody></table><table><thead><tr><th>命令模式</th><th>简介</th></tr></thead><tbody><tr><td>:w</td><td>将编辑过的文本保存</td></tr><tr><td>:w!</td><td>若文本属性为只读时，强制保存</td></tr><tr><td>:q</td><td>退出vim</td></tr><tr><td>:q!</td><td>不管编辑或未编辑都不保存退出</td></tr><tr><td>:wq</td><td>保存，退出</td></tr><tr><td>:e!</td><td>将文档还原成最原始状态</td></tr><tr><td>ZZ</td><td>若文档没有改动，则不储存离开，若文档改动过，则储存后离开，等同于:wq</td></tr><tr><td>:w [filename]</td><td>编辑后的文档另存为filename</td></tr><tr><td>:r [filename]</td><td>在当前光标所在行的下面读入filename文档的内容</td></tr><tr><td>:set nu</td><td>在每行的行首显示行号</td></tr><tr><td>:set nonu</td><td>取消行号</td></tr><tr><td>n1,n2 w [filename]</td><td>将n1到n2的内容另存为filename这个文档</td></tr><tr><td>:! command</td><td>暂时离开vim运行某个linux命令，例如 :! ls /home暂时列出/home目录下的文件，然后会提示按回车回到vim</td></tr></tbody></table><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="http://www.jianshu.com/p/bcbe916f97e1" target="_blank" rel="external">Vim入门基础</a></li><li><a href="http://vimdoc.sourceforge.net/" target="_blank" rel="external">Vim官方文档</a></li><li><a href="http://pan.baidu.com/s/1jGzbTBo" target="_blank" rel="external">Vim中文用户手册7_3.pdf</a></li></ol>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2017-08-13 Python网易云音乐热评]]></title>
      <url>http://hamstersi.github.io/2017/08/2017-08-13-Python%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E7%83%AD%E8%AF%84/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fijgpk4fn8j20uk1ou7db.jpg" alt="网易云音乐热评"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx3.sinaimg.cn/mw690/672d88aagy1fijgpiko3jj20uk1ouahf.jpg" alt="网易云音乐热评"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx3.sinaimg.cn/mw690/672d88aagy1fijgphjbg3j20uk1oun6x.jpg" alt="网易云音乐热评"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fijgpmx7zsj20uk1ouahx.jpg" alt="网易云音乐热评"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx4.sinaimg.cn/mw690/672d88aagy1fijgplgt22j20uk1ouk0c.jpg" alt="网易云音乐热评"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx3.sinaimg.cn/mw690/672d88aagy1fijgpq4f9fj20uk1ou7by.jpg" alt="网易云音乐热评"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx4.sinaimg.cn/mw690/672d88aagy1fijgpqzbm5j20uk1ou45l.jpg" alt="网易云音乐热评"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fijgpopmbfj20uk1ouk0v.jpg" alt="网易云音乐热评"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx3.sinaimg.cn/mw690/672d88aagy1fijgpnuuwtj20uk1ouqb9.jpg" alt="网易云音乐热评"></div></div></div></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2017-08-11 Python豆列住在植物园里]]></title>
      <url>http://hamstersi.github.io/2017/08/2017-08-11-Python%E8%B1%86%E5%88%97%E4%BD%8F%E5%9C%A8%E6%A4%8D%E7%89%A9%E5%9B%AD%E9%87%8C/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx3.sinaimg.cn/mw690/672d88aagy1fii9a2uvd1j20ku0t6mzu.jpg" alt="豆列-住在植物园里"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fii9a1h0e3j20ku0t6tc7.jpg" alt="豆列-住在植物园里"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx3.sinaimg.cn/mw690/672d88aagy1fii9a0zssvj20ku0t6whb.jpg" alt="豆列-住在植物园里"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx4.sinaimg.cn/mw690/672d88aagy1fii9a0rdq7j20ku0t6gny.jpg" alt="豆列-住在植物园里"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx1.sinaimg.cn/mw690/672d88aagy1fii9a0402kj20ku0t641y.jpg" alt="豆列-住在植物园里"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx3.sinaimg.cn/mw690/672d88aagy1fii99zhzkrj20ku0t6tau.jpg" alt="豆列-住在植物园里"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fii99yb4ulj20ku0t6tb3.jpg" alt="豆列-住在植物园里"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fii99yy4ujj20ku0t6gon.jpg" alt="豆列-住在植物园里"></div><div class="group-picture-column" style="width:33.333333333333336%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fii99xqg83j20ku0t6tb7.jpg" alt="豆列-住在植物园里"></div></div></div></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分享: 国家地理百年纪念典藏]]></title>
      <url>http://hamstersi.github.io/2017/08/%E5%88%86%E4%BA%AB-%E5%9B%BD%E5%AE%B6%E5%9C%B0%E7%90%86%E7%99%BE%E5%B9%B4%E7%BA%AA%E5%BF%B5%E5%85%B8%E8%97%8F/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><blockquote><div class="testdiv"><div style="height:35px;line-height:35px;padding-left:65px;background:url(http://wx4.sinaimg.cn/mw690/672d88aagy1fidrzu0hx8j2046046t9e.jpg);background-size:35px 35px;background-repeat:no-repeat"><span><p style="font-size:20px;text-transform:uppercase"><strong><a href="https://pan.baidu.com/s/1bphH8NP" target="_blank" rel="external">密码：bdnu</a></strong></p></span></div></div></blockquote><p style="margin-top:20px">它让您坐在家中就可以遨游世界、感受各地独特的风土民情，穿梭古今，走过历史，更带领您深入原始的野性世界。国家地理第一、二辑，精选全球纪录片领导品牌 – 国家地理一百部代表影片，主题内容包罗万象，让您一次珍藏。除了详实而深入的内容之外，专业的拍摄团队和世界级顶尖摄影师们，足迹行遍世界各个角落，甚至冒著生命危险，在刹那间捕捉令人瞠目结舌、惊叹不已的永恒画面，带给观众无比的影音视觉享受。包括寰宇采风、世界最后最美的地方、掠食王国、探险、历史怀旧、最喜欢的动物、生态巡礼、狂暴大地、珍稀动物、抢救生态、发现古文明、考古探险、军事战略等系列节目。</p><a id="more"></a><h5 id="资源简介"><a href="#资源简介" class="headerlink" title="资源简介"></a>资源简介</h5><p>◆原　名：National Geographic 100 VOL01-100<br>◆译　名：国家地理百年纪念典藏 01-100<br>◆类　型：专题片<br>◆片　长：100 x 54 分钟<br>◆上　映：2004年<br>◆国　家：美国<br>◆语　言：英语/普通话<br>◆字　幕：中文/英语<br>◆文　件：1CD×100, (699MB×100)</p><h5 id="片单明细"><a href="#片单明细" class="headerlink" title="片单明细"></a>片单明细</h5><p>1.埃及：永恒之路<br>2.浴火重生<br>3.雨林<br>4.情同手足黑猩猩<br>5.重返喜马拉雅山<br>6.超视觉世界<br>7.北极冰原<br>8.黄石公园<br>9.巴拿马生态<br>10.大堡礁<br>11.澳洲袋鼠王国<br>12.神秘三角洲<br>13.埃及秘辛<br>14.饱受劫难的圣城<br>15.鬼斧神工巴里岛<br>16.西班牙之魂<br>17.伟大的印度铁路<br>18.飞越非洲<br>19.恐龙猎人<br>20.猫咪的秘密日记<br>21.好马一族<br>22.狂野的海豚<br>23.狗儿真奇妙<br>24.拯救大熊猫<br>25.时空大冒险<br>26.世纪探险家<br>27.茫茫深海铁达尼<br>28.南极冰原<br>29.神秘的地底世界<br>30.火车之恋<br>31.失落的马雅文明<br>32.世纪宝藏<br>33.非洲野生动物<br>34.澳洲动物探秘<br>35.虎域<br>36.鳄鱼王国<br>37.犀牛的哀歌<br>38.白狼<br>39.象族<br>40.美女与野兽-豹的故事<br>41.维苏威火山的阴影<br>42.国家地理百年纪念<br>43.俾斯麦战舰<br>44.超级摄影师<br>45.暗夜之王<br>46.非洲历险<br>47.眼镜蛇王<br>48.森蚺奇境<br>49.猫谜<br>50.沧海浮生记。51.猎鲨<br>52.爱尔兰骏马<br>53.捍卫花园<br>54.加拉帕哥髭蜥<br>55.窥探自然<br>56.深海搜奇<br>57.黑猩猩<br>58.小宇宙:致命一击<br>59.雨林顶探险家<br>60.丛林海战<br>61.伟大的吴哥窟<br>62.白宫<br>63.大雪崩<br>64.致命流沙<br>65.火山<br>66.愤怒的地球<br>67.杀人浪<br>68.气旋风暴<br>69.雪地之虎<br>70.安地斯山羊驼<br>71.美国频临绝种动物<br>72.喀拉哈里之狐<br>73.大海怪<br>74.加勒比海底世界<br>75.非洲古文明<br>76.中国大漠之宝<br>77.印度帝国<br>78.印加古城之迷<br>79.美索不达米亚文明<br>80.西藏禁地<br>81.珍珠港<br>82.自然的蜕变<br>83.与象共舞<br>84.孤鹰林白<br>85.生命之歌<br>86.深海探险队<br>87.中途岛战役<br>88.二次大战秘辛<br>89.巴拿马运河<br>90.兴登堡飞船<br>91.航向太空<br>92.超越颠峰<br>93.丝路<br>94.地中海沉船之迷<br>95.玛雅王国之秘<br>96.爱琴海古文明<br>97.冥界的呼唤<br>98.人类起源之迷<br>99.响尾蛇<br>100.鳄鱼的最后晚餐</p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python图像处理库Pillow入门]]></title>
      <url>http://hamstersi.github.io/2017/08/Python%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%BA%93Pillow%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>Pillow是Python里的图像处理库（PIL：Python Image Library），提供了了广泛的文件格式支持，强大的图像处理能力，主要包括图像储存、图像显示、格式转换以及基本的图像处理操作等。</p><h1 id="使用-Image-类"><a href="#使用-Image-类" class="headerlink" title="使用 Image 类"></a>使用 Image 类</h1><p>PIL最重要的类是 Image class, 你可以通过多种方法创建这个类的实例；你可以从文件加载图像，或者处理其他图像, 或者从 scratch 创建。</p><p>要从文件加载图像，可以使用open( )函数，在Image模块中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </div><div class="line">im = Image.open(<span class="string">"E:/photoshop/1.jpg"</span>)</div></pre></td></tr></table></figure><a id="more"></a><p>加载成功后，将返回一个Image对象，可以通过使用示例属性查看文件内容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">print(im.format, im.size, im.mode)  </div><div class="line">(<span class="string">'JPEG'</span>, (<span class="number">600</span>, <span class="number">351</span>), <span class="string">'RGB'</span>)</div></pre></td></tr></table></figure><p>format 这个属性标识了图像来源。如果图像不是从文件读取它的值就是None。size属性是一个二元tuple，包含width和height（宽度和高度，单位都是px）。 mode 属性定义了图像bands的数量和名称，以及像素类型和深度。常见的modes 有 “L” (luminance) 表示灰度图像, “RGB” 表示真彩色图像, and “CMYK” 表示出版图像。</p><p>如果文件打开错误，返回 IOError 错误。只要你有了 Image 类的实例，你就可以通过类的方法处理图像。比如，下列方法可以显示图像：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">im.show()</div></pre></td></tr></table></figure><h1 id="读写图像"><a href="#读写图像" class="headerlink" title="读写图像"></a>读写图像</h1><p>PIL 模块支持大量图片格式。使用在 Image 模块的 open() 函数从磁盘读取文件。你不需要知道文件格式就能打开它，这个库能够根据文件内容自动确定文件格式。要保存文件，使用 Image 类的 save() 方法。保存文件的时候文件名变得重要了。除非你指定格式，否则这个库将会以文件名的扩展名作为格式保存。</p><p>加载文件，并转化为png格式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </div><div class="line"><span class="keyword">import</span> os  </div><div class="line"><span class="keyword">import</span> sys  </div><div class="line">  </div><div class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:  </div><div class="line">    f,e = os.path.splitext(infile)  </div><div class="line">    outfile = f +<span class="string">".png"</span>  </div><div class="line">    <span class="keyword">if</span> infile != outfile:  </div><div class="line">        <span class="keyword">try</span>:  </div><div class="line">            Image.open(infile).save(outfile)  </div><div class="line">        <span class="keyword">except</span> IOError:  </div><div class="line">            print(<span class="string">"Cannot convert"</span>, infile)</div></pre></td></tr></table></figure><p>save() 方法的第二个参数可以指定文件格式。</p><h1 id="创建缩略图"><a href="#创建缩略图" class="headerlink" title="创建缩略图"></a>创建缩略图</h1><p>缩略图是网络开发或图像软件预览常用的一种基本技术，使用Python的Pillow图像库可以很方便的建立缩略图，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># create thumbnail  </span></div><div class="line">size = (<span class="number">128</span>,<span class="number">128</span>)  </div><div class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> glob.glob(<span class="string">"E:/photoshop/*.jpg"</span>):  </div><div class="line">    f, ext = os.path.splitext(infile)  </div><div class="line">    img = Image.open(infile)  </div><div class="line">    img.thumbnail(size,Image.ANTIALIAS)  </div><div class="line">    img.save(f+<span class="string">".thumbnail"</span>,<span class="string">"JPEG"</span>)</div></pre></td></tr></table></figure><p>上段代码对photoshop下的jpg图像文件全部创建缩略图，并保存，glob模块是一种智能化的文件名匹配技术，在批图像处理中经常会用到。</p><p>注意：Pillow库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图片大小和压缩方式无关。</p><h1 id="图像的剪切、粘贴与合并操作"><a href="#图像的剪切、粘贴与合并操作" class="headerlink" title="图像的剪切、粘贴与合并操作"></a>图像的剪切、粘贴与合并操作</h1><p>Image 类包含的方法允许你操作图像部分选区，PIL.Image.Image.crop 方法获取图像的一个子矩形选区，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># crop, paste and merge  </span></div><div class="line">im = Image.open(<span class="string">"E:/photoshop/lena.jpg"</span>)  </div><div class="line">box = (<span class="number">100</span>,<span class="number">100</span>,<span class="number">300</span>,<span class="number">300</span>)  </div><div class="line">region = im.crop(box)</div></pre></td></tr></table></figure><p>矩形选区有一个4元元组定义，分别表示左、上、右、下的坐标。这个库以左上角为坐标原点，单位是px，所以上诉代码复制了一个 200x200 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">region = region.transpose(Image.ROTATE_180)  </div><div class="line">im.paste(region, box)</div></pre></td></tr></table></figure><p>当你粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而你不必保证矩形选区和原图的颜色模式一致，因为矩形选区会被自动转换颜色。</p><h1 id="分离和合并颜色通道"><a href="#分离和合并颜色通道" class="headerlink" title="分离和合并颜色通道"></a>分离和合并颜色通道</h1><p>对于多通道图像，有时候在处理时希望能够分别对每个通道处理，处理完成后重新合成多通道，在Pillow中，很简单，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">r,g,b = im.split()  </div><div class="line">im = Image.merge(<span class="string">"RGB"</span>, (r,g,b))</div></pre></td></tr></table></figure><p>对于split（ ）函数，如果是单通道的，则返回其本身，否则，返回各个通道。</p><h1 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h1><p>对图像进行几何变换是一种基本处理，在Pillow中包括resize( )和rotate( )，如用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">out = im.resize((<span class="number">128</span>,<span class="number">128</span>))  </div><div class="line">out = im.rotate(<span class="number">45</span>)  <span class="comment"># degree conter-clockwise</span></div></pre></td></tr></table></figure><p>其中，resize( )函数的参数是一个新图像大小的元祖，而rotate( )则需要输入顺时针的旋转角度。在Pillow中，对于一些常见的旋转作了专门的定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">out = im.transpose(Image.FLIP_LEFT_RIGHT)  </div><div class="line">out = im.transpose(Image.FLIP_TOP_BOTTOM)  </div><div class="line">out = im.transpose(Image.ROTATE_90)  </div><div class="line">out = im.transpose(Image.ROTATE_180)  </div><div class="line">out = im.transpose(Image.ROTATE_270)</div></pre></td></tr></table></figure><h1 id="颜色空间变换"><a href="#颜色空间变换" class="headerlink" title="颜色空间变换"></a>颜色空间变换</h1><p>在处理图像时，根据需要进行颜色空间的转换，如将彩色转换为灰度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cmyk = im.convert(<span class="string">"CMYK"</span>)  </div><div class="line">gray = im.convert(<span class="string">"L"</span>)</div></pre></td></tr></table></figure><h1 id="图像滤波"><a href="#图像滤波" class="headerlink" title="图像滤波"></a>图像滤波</h1><p>图像滤波在ImageFilter 模块中，在该模块中，预先定义了很多增强滤波器，可以通过filter( )函数使用，预定义滤波器包括：<br>BLUR、CONTOUR、DETAIL、EDGE_ENHANCE、EDGE_ENHANCE_MORE、EMBOSS、FIND_EDGES、SMOOTH、SMOOTH_MORE、SHARPEN。其中BLUR就是均值滤波，CONTOUR找轮廓，FIND_EDGES边缘检测，使用该模块时，需先导入，使用方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFilter  </div><div class="line">  </div><div class="line">imgF = Image.open(<span class="string">"E:/photoshop/lena.jpg"</span>)  </div><div class="line">outF = imgF.filter(ImageFilter.DETAIL)  </div><div class="line">conF = imgF.filter(ImageFilter.CONTOUR)  </div><div class="line">edgeF = imgF.filter(ImageFilter.FIND_EDGES)  </div><div class="line">imgF.show()  </div><div class="line">outF.show()  </div><div class="line">conF.show()  </div><div class="line">edgeF.show()</div></pre></td></tr></table></figure><p>除此以外，ImageFilter模块还包括一些扩展性强的滤波器.</p><h1 id="图像增强"><a href="#图像增强" class="headerlink" title="图像增强"></a>图像增强</h1><p>图像增强也是图像预处理中的一个基本技术，Pillow中的图像增强函数主要在ImageEnhance模块下，通过该模块可以调节图像的颜色、对比度和饱和度和锐化等：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageEnhance  </div><div class="line">  </div><div class="line">imgE = Image.open(<span class="string">"E:/photoshop/lena.jpg"</span>)  </div><div class="line">imgEH = ImageEnhance.Contrast(imgE)  </div><div class="line">imgEH.enhance(<span class="number">1.3</span>).show(<span class="string">"30% more contrast"</span>)</div></pre></td></tr></table></figure><p>图像增强：</p><p><strong>class PIL.ImageEnhance.Color(image)</strong></p><p>Adjust image color balance. This class can be used to adjust the colour balance of an image, in a manner similar to the controls on a colour TV set. An enhancement factor of 0.0 gives a black and white image. A factor of 1.0 gives the original image.</p><p><strong>class PIL.ImageEnhance.Contrast(image)</strong></p><p>Adjust image contrast. This class can be used to control the contrast of an image, similar to the contrast control on a TV set. An enhancement factor of 0.0 gives a solid grey image. A factor of 1.0 gives the original image.</p><p><strong>class PIL.ImageEnhance.Brightness(image)</strong></p><p>Adjust image brightness. This class can be used to control the brighntess of an image. An enhancement factor of 0.0 gives a black image. A factor of 1.0 gives the original image.</p><p><strong>class PIL.ImageEnhance.Sharpness(image)</strong></p><p>Adjust image sharpness. This class can be used to adjust the sharpness of an image. An enhancement factor of 0.0 gives a blurred image, a factor of 1.0 gives the original image, and a factor of 2.0 gives a sharpened image.</p><p>图像增强的详细内容可以参考：<a href="http://pillow-cn.readthedocs.io/en/latest/_modules/PIL/ImageEnhance.html#Color" target="_blank" rel="external">PIL/ImageEnhance</a></p><h1 id="PIL实现图片合成"><a href="#PIL实现图片合成" class="headerlink" title="PIL实现图片合成"></a>PIL实现图片合成</h1><p>在项目中需要将两张图片合在一起。遇到两种情况，一种就是两张非透明图片的合成， 一种是涉及到透明png的合成。相关API见 <a href="http://pillow.readthedocs.io/en/latest/reference/Image.html" target="_blank" rel="external">http://pillow.readthedocs.io/en/latest/reference/Image.html</a></p><p>第一种情况，直接将两张图片合在一起就可以了。如下图所示，将两张图片合在一起。</p><p><img src="http://wx2.sinaimg.cn/large/672d88aagy1fibgknaorij20ma07xqbt.jpg" alt="FirPaste"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="comment">#加载底图</span></div><div class="line">base_img = Image.open(<span class="string">ur'D:\Desktop\1.png'</span>)</div><div class="line"><span class="comment"># 可以查看图片的size和mode，常见mode有RGB和RGBA，RGBA比RGB多了Alpha透明度</span></div><div class="line"><span class="comment"># print base_img.size, base_img.mode</span></div><div class="line">box = (<span class="number">166</span>, <span class="number">64</span>, <span class="number">320</span>, <span class="number">337</span>)  <span class="comment"># 底图上需要P掉的区域</span></div><div class="line"></div><div class="line"><span class="comment">#加载需要P上去的图片</span></div><div class="line">tmp_img = Image.open(<span class="string">ur'D:\Desktop\2.png'</span>)</div><div class="line"><span class="comment">#这里可以选择一块区域或者整张图片</span></div><div class="line"><span class="comment">#region = tmp_img.crop((0,0,304,546)) #选择一块区域或者使用整张图片</span></div><div class="line">region = tmp_img</div><div class="line"></div><div class="line"><span class="comment">#使用 paste(region, box) 方法将图片粘贴到另一种图片上去.</span></div><div class="line"><span class="comment"># 注意，region的大小必须和box的大小完全匹配。</span></div><div class="line"><span class="comment"># 但是两张图片的mode可以不同，合并的时候回自动转化。</span></div><div class="line"><span class="comment"># 如果需要保留透明度，则使用RGMA mode</span></div><div class="line"><span class="comment"># 提前将图片进行缩放，以适应box区域大小</span></div><div class="line"><span class="comment"># region = region.rotate(180) #对图片进行旋转</span></div><div class="line">region = region.resize((box[<span class="number">2</span>] - box[<span class="number">0</span>], box[<span class="number">3</span>] - box[<span class="number">1</span>]))</div><div class="line">base_img.paste(region, box)</div><div class="line"><span class="comment">#base_img.show() # 查看合成的图片</span></div><div class="line">base_img.save(<span class="string">'./out.png'</span>) <span class="comment">#保存图片</span></div></pre></td></tr></table></figure><p>第一种情况时候规则的图片进行合并，比如矩形，难以对于任意形状的图片。对于任意形状的合并可以考虑使用透明的PNG来完成。</p><p>第二种情况，将非透明的图片放在底部，上面放一张局部透明的png图片，然后合成一张图片。</p><p><img src="http://wx1.sinaimg.cn/large/672d88aagy1fibgkog5s8j20la081tgf.jpg" alt="SecPaste"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div><div class="line"><span class="comment">#加载中间透明的手机图片</span></div><div class="line">base_img = Image.open(<span class="string">ur'D:\Desktop\3.png'</span>)</div><div class="line"><span class="comment">#新建透明底图，大小和手机图一样，mode使用RGBA，保留Alpha透明度，颜色为透明</span></div><div class="line"><span class="comment">#Image.new(mode, size, color=0)，color可以用tuple表示，分别表示RGBA的值</span></div><div class="line">target = Image.new(<span class="string">'RGBA'</span>, base_img.size, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</div><div class="line">box = (<span class="number">166</span>, <span class="number">64</span>, <span class="number">320</span>, <span class="number">337</span>) <span class="comment">#区域</span></div><div class="line"><span class="comment"># 加载需要狐狸像</span></div><div class="line">region = Image.open(<span class="string">ur'D:\Desktop\4.png'</span>)</div><div class="line">region = region.rotate(<span class="number">180</span>) <span class="comment">#旋转180度</span></div><div class="line"><span class="comment">#确保图片是RGBA格式，大小和box区域一样</span></div><div class="line">region = region.convert(<span class="string">"RGBA"</span>)</div><div class="line">region = region.resize((box[<span class="number">2</span>] - box[<span class="number">0</span>], box[<span class="number">3</span>] - box[<span class="number">1</span>]))</div><div class="line"><span class="comment">#先将狐狸像合成到底图上</span></div><div class="line">target.paste(region,box)</div><div class="line"><span class="comment">#将手机图覆盖上去，中间透明区域将狐狸像显示出来。</span></div><div class="line"><span class="comment">#第一个参数表示需要粘贴的图像，中间的是坐标，最后是一个是mask图片，用于指定透明区域，将底图显示出来。</span></div><div class="line">target.paste(base_img,(<span class="number">0</span>,<span class="number">0</span>),base_img) </div><div class="line"><span class="comment"># target.show()</span></div><div class="line">target.save(<span class="string">'./out.png'</span>)  <span class="comment"># 保存图片</span></div></pre></td></tr></table></figure><p>除了以上介绍的内容外，Pillow还有很多强大的功能：<br>PIL.Image.alpha_composite(im1, im2)<br>PIL.Image.blend(im1, im2, alpha)<br>PIL.Image.composite(image1, image2, mask)<br>PIL.Image.eval(image, <em>args)<br>PIL.Image.fromarray(obj, mode=None)<br>PIL.Image.frombuffer(mode, size, data, decoder_name=’raw’, </em>args)</p><p>想了解更多，请参考：<a href="http://pillow-cn.readthedocs.io/en/latest/reference/Image.html#module-PIL.Image" target="_blank" rel="external">Image Module</a>和 <a href="http://pillow.readthedocs.io/en/latest/reference/index.html" target="_blank" rel="external">Pillow Reference</a></p><p>参考资料：<br>1、<a href="http://pillow-cn.readthedocs.io/en/latest/handbook/tutorial.html" target="_blank" rel="external">PLI–Pillow快速入门</a></p><blockquote><p><a href="http://blog.csdn.net/kezunhai/article/details/46446153" target="_blank" rel="external"><strong>原文链接: Belial计算机视觉&amp;机器视觉专栏</strong></a></p></blockquote>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python爬虫：常用爬虫技巧]]></title>
      <url>http://hamstersi.github.io/2017/08/Python%E7%88%AC%E8%99%AB%EF%BC%9A%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E7%88%AC%E8%99%AB%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="基本抓取网页"><a href="#基本抓取网页" class="headerlink" title="基本抓取网页"></a>基本抓取网页</h1><p>GET</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">importurl lib2</div><div class="line"></div><div class="line">url = <span class="string">"http://www.baidu.com"</span></div><div class="line">response = urllib2.urlopen(url)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><p>POST</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">url = <span class="string">"http://abcde.com"</span></div><div class="line">form = &#123;<span class="string">'name'</span>:<span class="string">'abc'</span>,<span class="string">'password'</span>:<span class="string">'1234'</span>&#125;</div><div class="line">form_data = urllib.urlencode(form)</div><div class="line">request = urllib2.Request(url,form_data)</div><div class="line">response = urllib2.urlopen(request)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><a id="more"></a><h1 id="使用代理IP"><a href="#使用代理IP" class="headerlink" title="使用代理IP"></a>使用代理IP</h1><p>在开发爬虫过程中经常会遇到IP被封掉的情况，这时就需要用到代理IP。在urllib2包中有ProxyHandler类，通过此类可以设置代理访问网页，如下代码片段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">proxy = urllib2.ProxyHandler(&#123;<span class="string">'http'</span>: <span class="string">'127.0.0.1:8087'</span>&#125;)</div><div class="line">opener = urllib2.build_opener(proxy)</div><div class="line">urllib2.install_opener(opener)</div><div class="line">response = urllib2.urlopen(<span class="string">'http://www.baidu.com'</span>)</div><div class="line"><span class="keyword">print</span> response.read()</div></pre></td></tr></table></figure><h1 id="Cookies处理"><a href="#Cookies处理" class="headerlink" title="Cookies处理"></a>Cookies处理</h1><p>cookies是某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据(通常经过加密)，python提供了cookielib模块用于处理cookies，cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2, cookielib</div><div class="line"></div><div class="line">cookie_support= urllib2.HTTPCookieProcessor(cookielib.CookieJar())</div><div class="line">opener = urllib2.build_opener(cookie_support)</div><div class="line">urllib2.install_opener(opener)</div><div class="line">content = urllib2.urlopen(<span class="string">'http://XXXX'</span>).read()</div></pre></td></tr></table></figure><p>关键在于CookieJar()，它用于管理HTTP cookie值、存储HTTP请求生成的cookie、向传出的HTTP请求添加cookie的对象。整个cookie都存储在内存中，对CookieJar实例进行垃圾回收后cookie也将丢失，所有过程都不需要单独去操作。手动添加cookie:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cookie = "PHPSESSID=91rurfqm2329bopnosfu4fvmu7; </div><div class="line">		  kmsign=55d2c12c9b1e3; </div><div class="line">		  KMUID=b6Ejc1XSwPq9o756AxnBAg="</div><div class="line">request.add_header("Cookie", cookie)</div></pre></td></tr></table></figure><h1 id="伪装成浏览器"><a href="#伪装成浏览器" class="headerlink" title="伪装成浏览器"></a>伪装成浏览器</h1><p>某些网站反感爬虫的到访，于是对爬虫一律拒绝请求。所以用urllib2直接访问网站经常会出现HTTP Error 403: Forbidden的情况.对有些 header 要特别留意，Server 端会针对这些 header 做检查:</p><p>1.User-Agent 有些 Server 或 Proxy 会检查该值，用来判断是否是浏览器发起的 Request<br>2.Content-Type 在使用 REST 接口时，Server 会检查该值，用来确定 HTTP Body 中的内容该怎样解析。</p><p>这时可以通过修改http包中的header来实现，代码片段如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2</div><div class="line"></div><div class="line">headers = &#123;</div><div class="line">   <span class="string">'User-Agent'</span>:<span class="string">'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US; rv:1.9.1.6) Gecko/20091201 Firefox/3.5.6'</span></div><div class="line">&#125;</div><div class="line">request = urllib2.Request(</div><div class="line">    url = <span class="string">'http://my.oschina.net/jhao104/blog?catalog=3463517'</span>,</div><div class="line">    headers = headers</div><div class="line">)</div><div class="line"><span class="keyword">print</span> urllib2.urlopen(request).read()</div></pre></td></tr></table></figure><h1 id="页面解析"><a href="#页面解析" class="headerlink" title="页面解析"></a>页面解析</h1><p>对于页面解析最强大的当然是正则表达式，这个对于不同网站不同的使用者都不一样，就不用过多的说明，附两个比较好的网址：<a href="http://www.cnblogs.com/huxi/archive/2010/07/04/1771073.html" target="_blank" rel="external">正则表达式入门</a>, <a href="http://tool.oschina.net/regex/" target="_blank" rel="external">正则表达式在线测试</a>。其次就是解析库了，常用的有两个lxml和BeautifulSoup，对于这两个的使用介绍两个比较好的网站：<a href="http://my.oschina.net/jhao104/blog/639448" target="_blank" rel="external">lxml</a>, <a href="http://cuiqingcai.com/1319.html" target="_blank" rel="external">BeautifulSoup</a></p><p>对于这两个库，我的评价是，都是HTML/XML的处理库，Beautifulsoup纯python实现，效率低，但是功能实用，比如能用通过结果搜索获得某个HTML节点的源码；lxmlC语言编码，高效，支持Xpath</p><h1 id="验证码的处理"><a href="#验证码的处理" class="headerlink" title="验证码的处理"></a>验证码的处理</h1><p>对于一些简单的验证码，可以进行简单的识别。本人也只进行过一些简单的验证码识别。但是有些反人类的验证码，比如12306，可以通过打码平台进行人工打码，当然这是要付费的。</p><h1 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h1><p>有没有遇到过某些网页，不论怎么转码都是一团乱码。哈哈，那说明你还不知道许多web服务具有发送压缩数据的能力，这可以将网络线路上传输的大量数据消减 60% 以上。这尤其适用于 XML web 服务，因为 XML 数据 的压缩率可以很高。但是一般服务器不会为你发送压缩数据，除非你告诉服务器你可以处理压缩数据。于是需要这样修改代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib2, httplib</div><div class="line">request = urllib2.Request(<span class="string">'http://xxxx.com'</span>)</div><div class="line">request.add_header(<span class="string">'Accept-encoding'</span>, <span class="string">'gzip'</span>)        </div><div class="line">opener = urllib2.build_opener()</div><div class="line">f = opener.open(request)</div></pre></td></tr></table></figure><p>这是关键:创建Request对象，添加一个 Accept-encoding 头信息告诉服务器你能接受 gzip 压缩数据, 然后就是解压缩数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> StringIO</div><div class="line"><span class="keyword">import</span> gzip</div><div class="line"></div><div class="line">compresseddata = f.read() </div><div class="line">compressedstream = StringIO.StringIO(compresseddata)</div><div class="line">gzipper = gzip.GzipFile(fileobj=compressedstream) </div><div class="line"><span class="keyword">print</span> gzipper.read()</div></pre></td></tr></table></figure><h1 id="多线程并发抓取"><a href="#多线程并发抓取" class="headerlink" title="多线程并发抓取"></a>多线程并发抓取</h1><p>单线程太慢的话，就需要多线程了，这里给个简单的线程池模板 这个程序只是简单地打印了1-10，但是可以看出是并发的。虽然说python的多线程很鸡肋，但是对于爬虫这种网络频繁型，还是能一定程度提高效率的。<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"><span class="keyword">from</span> Queue <span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</div><div class="line"><span class="comment">#q是任务队列, NUM是并发线程总数, JOBS是有多少任务</span></div><div class="line">q = Queue()</div><div class="line">NUM = <span class="number">2</span></div><div class="line">JOBS = <span class="number">10</span></div><div class="line"><span class="comment">#具体的处理函数，负责处理单个任务</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_somthing_using</span><span class="params">(arguments)</span>:</span></div><div class="line">    <span class="keyword">print</span> arguments</div><div class="line"><span class="comment">#这个是工作进程，负责不断从队列取数据并处理</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">working</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        arguments = q.get()</div><div class="line">        do_somthing_using(arguments)</div><div class="line">        sleep(<span class="number">1</span>)</div><div class="line">        q.task_done()</div><div class="line"><span class="comment">#fork NUM个线程等待队列</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(NUM):</div><div class="line">    t = Thread(target=working)</div><div class="line">    t.setDaemon(<span class="keyword">True</span>)</div><div class="line">    t.start()</div><div class="line"><span class="comment">#把JOBS排入队列</span></div><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(JOBS):</div><div class="line">    q.put(i)</div><div class="line"><span class="comment">#等待所有JOBS完成</span></div><div class="line">q.join()</div></pre></td></tr></table></figure><p></p><blockquote><p>原文链接: <a href="http://my.oschina.net/jhao104/blog/647308" target="_blank" rel="external">开源中国</a></p></blockquote>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python CSV & XLS Operation]]></title>
      <url>http://hamstersi.github.io/2017/08/Python%20CSV%20&amp;%20XLS%20Operation/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h1><p>最常用的一种方法，利用pandas包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line"></div><div class="line"><span class="comment">#任意的多组列表</span></div><div class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line">b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]    </div><div class="line"></div><div class="line"><span class="comment">#字典中的key值即为csv中列名</span></div><div class="line">dataframe = pd.DataFrame(&#123;<span class="string">'a_name'</span>:a,<span class="string">'b_name'</span>:b&#125;)</div><div class="line"></div><div class="line"><span class="comment">#将DataFrame存储为csv,index表示是否显示行名，default=True</span></div><div class="line">dataframe.to_csv(<span class="string">"test.csv"</span>,index=<span class="keyword">False</span>,sep=<span class="string">''</span>)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">   a_name  b_name</div><div class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">4</span></div><div class="line"><span class="number">1</span>       <span class="number">2</span>       <span class="number">5</span></div><div class="line"><span class="number">2</span>       <span class="number">3</span>       <span class="number">6</span></div></pre></td></tr></table></figure><a id="more"></a><p>同样pandas也提供简单的读csv方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div><div class="line">data = pd.read_csv(<span class="string">'test.csv'</span>)</div></pre></td></tr></table></figure><p>会得到一个DataFrame类型的data，不熟悉处理方法可以参考<a href="http://www.cnblogs.com/chaosimple/p/4153083.html" target="_blank" rel="external">pandas十分钟入门</a></p><p>另一种方法用csv包，一行一行写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> csv</div><div class="line"></div><div class="line"><span class="comment">#python2可以用file替代open</span></div><div class="line"><span class="keyword">with</span> open(<span class="string">"test.csv"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> csvfile: </div><div class="line">    writer = csv.writer(csvfile)</div><div class="line"></div><div class="line">    <span class="comment">#先写入columns_name</span></div><div class="line">    writer.writerow([<span class="string">"index"</span>,<span class="string">"a_name"</span>,<span class="string">"b_name"</span>])</div><div class="line">    <span class="comment">#写入多行用writerows</span></div><div class="line">    writer.writerows([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]])</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">index   a_name  b_name</div><div class="line"><span class="number">0</span>       <span class="number">1</span>       <span class="number">3</span></div><div class="line"><span class="number">1</span>       <span class="number">2</span>       <span class="number">3</span></div><div class="line"><span class="number">2</span>       <span class="number">3</span>       <span class="number">4</span></div></pre></td></tr></table></figure><p>读取csv文件用reader</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> csv</div><div class="line"><span class="keyword">with</span> open(<span class="string">"test.csv"</span>,<span class="string">"r"</span>) <span class="keyword">as</span> csvfile:</div><div class="line">    reader = csv.reader(csvfile)</div><div class="line">    <span class="comment">#这里不需要readlines</span></div><div class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> reader:</div><div class="line">        <span class="keyword">print</span> line</div></pre></td></tr></table></figure><h1 id="XLRD-amp-XLWT"><a href="#XLRD-amp-XLWT" class="headerlink" title="XLRD &amp; XLWT"></a>XLRD &amp; XLWT</h1><p>Python 操作excel主要用到xlrd和xlwt这两个库，即xlrd读excel，xlwt写excel。可从这里下载<a href="https://pypi.python.org/pypi" target="_blank" rel="external">https://pypi.python.org/pypi</a>。</p><h2 id="XLRD"><a href="#XLRD" class="headerlink" title="XLRD"></a>XLRD</h2><p>常见问题：读取日期、读合并单元格内容等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> xlrd</div><div class="line"><span class="keyword">import</span> xlwt</div><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date,datetime</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_excel</span><span class="params">()</span>:</span></div><div class="line">  <span class="comment"># 打开文件</span></div><div class="line">  workbook = xlrd.open_workbook(<span class="string">r'F:\demo.xlsx'</span>)</div><div class="line">  <span class="comment"># 获取所有sheet</span></div><div class="line">  <span class="keyword">print</span> workbook.sheet_names() <span class="comment"># [u'sheet1', u'sheet2']</span></div><div class="line">  sheet2_name = workbook.sheet_names()[<span class="number">1</span>]</div><div class="line"> </div><div class="line">  <span class="comment"># 根据sheet索引或者名称获取sheet内容</span></div><div class="line">  sheet2 = workbook.sheet_by_index(<span class="number">1</span>) <span class="comment"># sheet索引从0开始</span></div><div class="line">  sheet2 = workbook.sheet_by_name(<span class="string">'sheet2'</span>)</div><div class="line"> </div><div class="line">  <span class="comment"># sheet的名称，行数，列数</span></div><div class="line">  <span class="keyword">print</span> sheet2.name,sheet2.nrows,sheet2.ncols</div><div class="line"> </div><div class="line">  <span class="comment"># 获取整行和整列的值（数组）</span></div><div class="line">  rows = sheet2.row_values(<span class="number">3</span>) <span class="comment"># 获取第四行内容</span></div><div class="line">  cols = sheet2.col_values(<span class="number">2</span>) <span class="comment"># 获取第三列内容</span></div><div class="line">  <span class="keyword">print</span> rows</div><div class="line">  <span class="keyword">print</span> cols</div><div class="line"> </div><div class="line">  <span class="comment"># 获取单元格内容</span></div><div class="line">  <span class="keyword">print</span> sheet2.cell(<span class="number">1</span>,<span class="number">0</span>).value.encode(<span class="string">'utf-8'</span>)</div><div class="line">  <span class="keyword">print</span> sheet2.cell_value(<span class="number">1</span>,<span class="number">0</span>).encode(<span class="string">'utf-8'</span>)</div><div class="line">  <span class="keyword">print</span> sheet2.row(<span class="number">1</span>)[<span class="number">0</span>].value.encode(<span class="string">'utf-8'</span>)</div><div class="line">   </div><div class="line">  <span class="comment"># 获取单元格内容的数据类型</span></div><div class="line">  <span class="keyword">print</span> sheet2.cell(<span class="number">1</span>,<span class="number">0</span>).ctype</div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">  read_excel()</div></pre></td></tr></table></figure><p>Python读取excel中单元格的内容返回的有5种类型:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ctype : <span class="number">0</span> empty,<span class="number">1</span> string, <span class="number">2</span> number, <span class="number">3</span> date, <span class="number">4</span> boolean, <span class="number">5</span> error</div></pre></td></tr></table></figure><p><strong>1、python读取excel中单元格内容为日期的方式</strong></p><p>可做下简单处理，判断ctype是否等于3，如果等于3，则用时间格式处理：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (sheet.cell(row,col).ctype == <span class="number">3</span>):</div><div class="line">  date_value = xlrd.xldate_as_tuple(sheet.cell_value(rows,<span class="number">3</span>), book.datemode)</div><div class="line">  date_tmp = date(*date_value[:<span class="number">3</span>]).strftime(<span class="string">'%Y/%m/%d'</span>)</div></pre></td></tr></table></figure><p><strong>2、读取合并单元格的内容</strong></p><p>获取合并单元格的第一个cell的行列索引，才能读到值，读错了就是空值。即合并行单元格读取行的第一个索引，合并列单元格读取列的第一个索引。但是合并单元格可能出现空值，但是表格本身的普通单元格也可能是空值，要怎么获取单元格所谓的”第一个行或列的索引”呢？这就要先知道哪些是单元格是被合并的！</p><p>读取文件的时候需要将formatting_info参数设置为True，默认是False，所以获取合并的单元格数组为空。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>workbook = xlrd.open_workbook(<span class="string">r'F:\demo.xlsx'</span>, formatting_info = <span class="keyword">True</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sheet2 = workbook.sheet_by_name(<span class="string">'sheet2'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sheet2.merged_cells</div><div class="line">[(<span class="number">7</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">5</span>)]</div></pre></td></tr></table></figure><p>merged_cells返回的这四个参数的含义是：(row,row_range,col,col_range),其中[row,row_range)包括row,不包括row_range,col也是一样，即(1, 3, 4, 5)的含义是：第1到2行（不包括3）合并，(7, 8, 2, 5)的含义是：第2到4列合并。利用这个可以分别获取合并的单元格的内容：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sheet2.cell_value(<span class="number">1</span>,<span class="number">4</span>)  <span class="comment">#(1, 3, 4, 5)</span></div><div class="line">好朋友</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sheet2.cell_value(<span class="number">3</span>,<span class="number">4</span>)  <span class="comment">#(3, 6, 4, 5)</span></div><div class="line">同学</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> sheet2.cell_value(<span class="number">7</span>,<span class="number">2</span>)  <span class="comment">#(7, 8, 2, 5)</span></div><div class="line">暂无</div></pre></td></tr></table></figure><h2 id="XLWT"><a href="#XLWT" class="headerlink" title="XLWT"></a>XLWT</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="string">'''</span></div><div class="line">设置单元格样式</div><div class="line">'''</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_style</span><span class="params">(name,height,bold=False)</span>:</span></div><div class="line">  style = xlwt.XFStyle() <span class="comment"># 初始化样式</span></div><div class="line"> </div><div class="line">  font = xlwt.Font() <span class="comment"># 为样式创建字体</span></div><div class="line">  font.name = name <span class="comment"># 'Times New Roman'</span></div><div class="line">  font.bold = bold</div><div class="line">  font.color_index = <span class="number">4</span></div><div class="line">  font.height = height</div><div class="line"> </div><div class="line">  <span class="comment"># borders= xlwt.Borders()</span></div><div class="line">  <span class="comment"># borders.left= 6</span></div><div class="line">  <span class="comment"># borders.right= 6</span></div><div class="line">  <span class="comment"># borders.top= 6</span></div><div class="line">  <span class="comment"># borders.bottom= 6</span></div><div class="line"> </div><div class="line">  style.font = font</div><div class="line">  <span class="comment"># style.borders = borders</span></div><div class="line"> </div><div class="line">  <span class="keyword">return</span> style</div><div class="line"> </div><div class="line"> </div><div class="line"><span class="comment">#写excel</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_excel</span><span class="params">()</span>:</span></div><div class="line">  f = xlwt.Workbook() <span class="comment">#创建工作簿</span></div><div class="line"> </div><div class="line">  <span class="string">'''</span></div><div class="line">  创建第一个sheet:</div><div class="line">    sheet1</div><div class="line">  '''</div><div class="line">  sheet1 = f.add_sheet(<span class="string">u'sheet1'</span>,cell_overwrite_ok=<span class="keyword">True</span>) <span class="comment">#创建sheet</span></div><div class="line">  row0 = [<span class="string">u'业务'</span>,<span class="string">u'状态'</span>,<span class="string">u'北京'</span>,<span class="string">u'上海'</span>,<span class="string">u'广州'</span>,<span class="string">u'深圳'</span>,<span class="string">u'状态小计'</span>,<span class="string">u'合计'</span>]</div><div class="line">  column0 = [<span class="string">u'机票'</span>,<span class="string">u'船票'</span>,<span class="string">u'火车票'</span>,<span class="string">u'汽车票'</span>,<span class="string">u'其它'</span>]</div><div class="line">  status = [<span class="string">u'预订'</span>,<span class="string">u'出票'</span>,<span class="string">u'退票'</span>,<span class="string">u'业务小计'</span>]</div><div class="line"> </div><div class="line">  <span class="comment">#生成第一行</span></div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(row0)):</div><div class="line">    sheet1.write(<span class="number">0</span>,i,row0[i],set_style(<span class="string">'Times New Roman'</span>,<span class="number">220</span>,<span class="keyword">True</span>))</div><div class="line"> </div><div class="line">  <span class="comment">#生成第一列和最后一列(合并4行)</span></div><div class="line">  i, j = <span class="number">1</span>, <span class="number">0</span></div><div class="line">  <span class="keyword">while</span> i &lt; <span class="number">4</span>*len(column0) <span class="keyword">and</span> j &lt; len(column0):</div><div class="line">    sheet1.write_merge(i,i+<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,column0[j],set_style(<span class="string">'Arial'</span>,<span class="number">220</span>,<span class="keyword">True</span>)) <span class="comment">#第一列</span></div><div class="line">    sheet1.write_merge(i,i+<span class="number">3</span>,<span class="number">7</span>,<span class="number">7</span>) <span class="comment">#最后一列"合计"</span></div><div class="line">    i += <span class="number">4</span></div><div class="line">    j += <span class="number">1</span></div><div class="line"> </div><div class="line">  sheet1.write_merge(<span class="number">21</span>,<span class="number">21</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="string">u'合计'</span>,set_style(<span class="string">'Times New Roman'</span>,<span class="number">220</span>,<span class="keyword">True</span>))</div><div class="line"> </div><div class="line">  <span class="comment">#生成第二列</span></div><div class="line">  i = <span class="number">0</span></div><div class="line">  <span class="keyword">while</span> i &lt; <span class="number">4</span>*len(column0):</div><div class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,len(status)):</div><div class="line">      sheet1.write(j+i+<span class="number">1</span>,<span class="number">1</span>,status[j])</div><div class="line">    i += <span class="number">4</span></div><div class="line"> </div><div class="line">  f.save(<span class="string">'demo1.xlsx'</span>) <span class="comment">#保存文件</span></div><div class="line"> </div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">  <span class="comment">#generate_workbook()</span></div><div class="line">  <span class="comment">#read_excel()</span></div><div class="line">  write_excel()</div></pre></td></tr></table></figure><p>需要稍作解释的就是write_merge方法：write_merge(x, x + m, y, w + n, string, sytle)</p><p>x表示行，y表示列，m表示跨行个数，n表示跨列个数，string表示要写入的单元格内容，style表示单元格样式。其中，x，y，w，h，都是以0开始计算的。</p><p>这个和xlrd中的读合并单元格的不太一样。</p><p>如上述：sheet1.write_merge(21,21,0,1,u’合计’,set_style(‘Times New Roman’,220,True))</p><p>即在22行合并第1,2列，合并后的单元格内容为”合计”，并设置了style。</p><p>如果需要创建多个sheet，则只要f.add_sheet即可。</p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python3 编码]]></title>
      <url>http://hamstersi.github.io/2017/07/Python3%20%E7%BC%96%E7%A0%81/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>字符串是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。</p><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是<code>65535</code>，4个字节可以表示的最大整数是<code>4294967295</code>。</p><p>由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母<code>A</code>的编码是<code>65</code>，小写字母<code>z</code>的编码是<code>122</code>。</p><a id="more"></a><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p>Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母<code>A</code>用ASCII编码是十进制的<code>65</code>，二进制的<code>01000001</code>；</p><p>字符<code>0</code>用ASCII编码是十进制的<code>48</code>，二进制的<code>00110000</code>，注意字符<code>&#39;0&#39;</code>和整数<code>0</code>是不同的；</p><p>汉字已经超出了ASCII编码的范围，用Unicode编码是十进制的<code>20013</code>，二进制的<code>01001110 00101101</code>。</p><p>如果把ASCII编码的<code>A</code>用Unicode编码，只需要在前面补0就可以，因此，<code>A</code>的Unicode编码是<code>00000000 01000001</code>。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，又出现了把Unicode编码转化为“可变长编码”的<code>UTF-8</code>编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：</p><table><thead><tr><th>字符</th><th>ASCII</th><th>Unicode</th><th>UTF-8</th></tr></thead><tbody><tr><td>A</td><td>01000001</td><td>00000000 01000001</td><td>01000001</td></tr><tr><td>中</td><td>x</td><td>01001110 00101101</td><td>11100100 10111000 10101101</td></tr></tbody></table><p>从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p><p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p><p>在<strong>计算机内存中，统一使用Unicode编码</strong>，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p><p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：</p><p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：</p><p>所以你看到很多网页的源码上会有类似<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息，表示该网页正是用的UTF-8编码。</p><h3 id="Python的字符串"><a href="#Python的字符串" class="headerlink" title="Python的字符串"></a>Python的字符串</h3><p>在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'包含中文的str'</span>)</div><div class="line">包含中文的str</div></pre></td></tr></table></figure><p>对于单个字符的编码，Python提供了<code>ord()</code>函数获取字符的整数表示，<code>chr()</code>函数把编码转换为对应的字符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'A'</span>)</div><div class="line"><span class="number">65</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'中'</span>)</div><div class="line"><span class="number">20013</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</div><div class="line"><span class="string">'B'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">25991</span>)</div><div class="line"><span class="string">'文'</span></div></pre></td></tr></table></figure><p>如果知道字符的整数编码，还可以用十六进制这么写<code>str</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'\u4e2d\u6587'</span> // 中文</div></pre></td></tr></table></figure><h3 id="BYTE"><a href="#BYTE" class="headerlink" title="BYTE"></a>BYTE</h3><p>由于Python的字符串类型是<code>str</code>，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把<code>str</code>变为以字节为单位的<code>bytes</code>。</p><p>Python对<code>bytes</code>类型的数据用带<code>b</code>前缀的单引号或双引号表示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x = <span class="string">b'ABC'</span></div></pre></td></tr></table></figure><p>要注意区分’ABC’和b’ABC’，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。</p><p>以Unicode表示的<code>str</code>通过<code>encode()</code>方法可以编码为指定的<code>bytes</code>，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'ABC'</span>.encode(<span class="string">'ascii'</span>)</div><div class="line"><span class="string">b'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'中文'</span>.encode(<span class="string">'ascii'</span>)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</div><div class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode characters in position 0-1: ordinal not in range(128)</span></div></pre></td></tr></table></figure><p>纯英文的<code>str</code>可以用<code>ASCII</code>编码为<code>bytes</code>，内容是一样的，含有中文的<code>str</code>可以用<code>UTF-8</code>编码为<code>bytes</code>。含有中文的<code>str</code>无法用<code>ASCII</code>编码，因为中文编码的范围超过了<code>ASCII</code>编码的范围，Python会报错。</p><p>在<code>bytes</code>中，无法显示为ASCII字符的字节，用<code>\x##</code>显示。</p><p>反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是<code>bytes</code>。要把<code>bytes</code>变为<code>str</code>，就需要用<code>decode()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'ABC'</span>.decode(<span class="string">'ascii'</span>)</div><div class="line"><span class="string">'ABC'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>.decode(<span class="string">'utf-8'</span>)</div><div class="line"><span class="string">'中文'</span></div></pre></td></tr></table></figure><p>要计算<code>str</code>包含多少个字符，可以用<code>len()</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'ABC'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>)</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure><p><code>len()</code>函数计算的是<code>str</code>的字符数，如果换成<code>bytes</code>，<code>len()</code>函数就计算字节数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'ABC'</span>)</div><div class="line"><span class="number">3</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">b'\xe4\xb8\xad\xe6\x96\x87'</span>)</div><div class="line"><span class="number">6</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>len(<span class="string">'中文'</span>.encode(<span class="string">'utf-8'</span>))</div><div class="line"><span class="number">6</span></div></pre></td></tr></table></figure><p>1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。</p><p>在操作字符串时，我们经常遇到<code>str</code>和<code>bytes</code>的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对<code>str</code>和<code>bytes</code>进行转换。</p><p>Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python3</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div></pre></td></tr></table></figure><p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>在Python中，采用的格式化方式和C语言是一致的，用<code>%</code>实现，举例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">format % (...params)</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hello, %s'</span> % <span class="string">'world'</span></div><div class="line"><span class="string">'Hello, world'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Hi, %s, you have $%d.'</span> % (<span class="string">'Michael'</span>, <span class="number">1000000</span>)</div><div class="line"><span class="string">'Hi, Michael, you have $1000000.'</span></div></pre></td></tr></table></figure><p><code>%</code>运算符就是用来格式化字符串的。在字符串内部，<code>%s</code>表示用字符串替换，<code>%d</code>表示用整数替换，<code>%x</code>表示16进制整数，有几个<code>%?</code>占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个<code>%?</code>，括号可以省略。</p><p>格式化整数和浮点数还可以指定是否补0和整数与小数的位数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%2d-%02d'</span> % (<span class="number">3</span>, <span class="number">1</span>)</div><div class="line"><span class="string">' 3-01'</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'%.2f'</span> % <span class="number">3.1415926</span></div><div class="line"><span class="string">'3.14'</span></div></pre></td></tr></table></figure><p>有些时候，字符串里面的<code>%</code>是一个普通字符怎么办？这个时候就需要转义，用<code>%%</code>来表示一个<code>%</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'growth rate: %d %%'</span> % <span class="number">7</span></div><div class="line"><span class="string">'growth rate: 7 %'</span></div></pre></td></tr></table></figure><blockquote><p><strong>原文链接: </strong><a href="http://www.cnblogs.com/284628487a/p/5584714.html" target="_blank" rel="external"><strong>Coder25</strong></a></p></blockquote>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2017 - 07 Cat]]></title>
      <url>http://hamstersi.github.io/2017/07/2017-07%20Cat/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width:100%"><img src="http://wx4.sinaimg.cn/large/672d88aagy1fieutwjnnyj23y8280qv5.jpg" alt="Cat"></div></div><div class="group-picture-row"></div></div></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Vectorization with Intel Compiler]]></title>
      <url>http://hamstersi.github.io/2017/07/Vectorization%20with%20Intel%20Compiler/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Guidelines-to-Vectorize-Innermost-Loops"><a href="#Guidelines-to-Vectorize-Innermost-Loops" class="headerlink" title="Guidelines to Vectorize Innermost Loops"></a>Guidelines to Vectorize Innermost Loops</h1><p>Use:</p><ol><li><p>straight-line code (a single basic block).</p></li><li><p>vector data only; that is, arrays and invariant expressions on the right hand side of assignments.</p></li><li><p>only assignment statements.</p></li></ol><p>Avoid:</p><ol><li><p>function calls (other than math library calls).</p></li><li><p>non-vectorizable operations (either because the loop cannot be vectorized, or because an operation is emulated through a number of instructions).</p></li><li><p>mixing vectorizable types in the same loop (leads to lower resource utilization).</p></li><li><p>data-dependent loop exit conditions (leads to loss of vectorization).</p></li></ol><a id="more"></a><p>To make your code vectorizable, you will often need to make some changes to your loops. You should only make changes needed to enable vectorization, and avoid these common changes:</p><ol><li><p>loop unrolling, which the compiler performs automatically.</p></li><li><p>decomposing one loop with several statements in the body into several single-statement loops</p></li></ol><h1 id="Restrictions"><a href="#Restrictions" class="headerlink" title="Restrictions"></a>Restrictions</h1><table><thead><tr><th>Factor</th><th style="text-align:left">Description</th></tr></thead><tbody><tr><td>Hardware</td><td style="text-align:left">The compiler is limited by restrictions imposed by the underlying hardware. In the case of Intel® Streaming SIMD Extensions (Intel® SSE), the vector memory operations are limited to stride-1 accesses with a preference to 16-byte-aligned memory references. This means that if the compiler abstractly recognizes a loop as vectorizable, it still might not vectorize it for a distinct target architecture.</td></tr><tr><td>Style of source code</td><td style="text-align:left">The style in which you write source code can inhibit vectorization. For example, a common problem with global pointers is that they often prevent the compiler from being able to prove that two memory references refer to distinct locations. Consequently, this prevents certain reordering transformations.</td></tr></tbody></table><p>Many stylistic issues that prevent automatic vectorization by compilers are found in loop structures. The ambiguity arises from the complexity of the keywords, operators, data references, pointer arithmetic, and memory operations within the loop bodies.</p><h1 id="Guidelines-for-Writing-Vectorizable-Code"><a href="#Guidelines-for-Writing-Vectorizable-Code" class="headerlink" title="Guidelines for Writing Vectorizable Code"></a>Guidelines for Writing Vectorizable Code</h1><p>Follow these guidelines to write vectorizable code:</p><ol><li><p>Use simple for loops. Avoid complex loop termination conditions – the upper iteration limit must be invariant within the loop. For the innermost loop in a nest of loops, you could set the upper limit iteration to be a function of the outer loop indices.</p></li><li><p>Write straight-line code. Avoid branches such as switch, goto, or return statements; most function calls; or if constructs that can not be treated as masked assignments.</p></li><li><p>Avoid dependencies between loop iterations or at the least, avoid read-after-write dependencies.</p></li><li><p>Try to use array notations instead of the use of pointers. C programs in particular impose very few restrictions on the use of pointers; aliased pointers may lead to unexpected dependencies. Without help, the compiler often cannot tell whether it is safe to vectorize code containing pointers.</p></li><li><p>Wherever possible, use the loop index directly in array subscripts instead of incrementing a separate counter for use as an array address.</p></li><li><p>Access memory efficiently:</p></li><li><p>Favor inner loops with unit stride.</p><p>Minimize indirect addressing.</p><p>Align your data to 16-byte boundaries (for Intel® SSE instructions).</p></li><li><p>Choose a suitable data layout with care. Most multimedia extension instruction sets are rather sensitive to alignment. The data movement instructions of Intel® SSE, for example, operate much more efficiently on data that is aligned at a 16-byte boundary in memory. Therefore, the success of a vectorizing compiler also depends on its ability to select an appropriate data layout which, in combination with code restructuring (like loop peeling), results in aligned memory accesses throughout the program.</p></li><li><p>Use aligned data structures: Data structure alignment is the adjustment of any data object in relation with other objects.</p><p>You can use the declaration <code>__declspec(align)</code>.</p></li><li><p>Use structure of arrays (SoA) instead of array of structures (AoS): An array is the most common type of data structure that contains a contiguous collection of data items that can be accessed by an ordinal index. You can organize this data as an array of structures (AoS) or as a structure of arrays (SoA). While AoS organization is excellent for encapsulation it can be a hindrance for use of vector processing. To make vectorization of the resulting code more effective, you can also select appropriate data structures.</p></li></ol><h1 id="Obstacles-to-Vectorization"><a href="#Obstacles-to-Vectorization" class="headerlink" title="Obstacles to Vectorization"></a>Obstacles to Vectorization</h1><p>The following do not always prevent vectorization, but frequently either prevent it or cause the compiler to decide that vectorization would not be worthwhile.</p><h2 id="Non-contiguous-memory-access"><a href="#Non-contiguous-memory-access" class="headerlink" title="Non-contiguous memory access:"></a>Non-contiguous memory access:</h2><p>Four consecutive integers or floating-point values, or two consecutive doubles, may be loaded directly from memory in a single SSE instruction. But if the four integers are not adjacent, they must be loaded separately using multiple instructions, which is considerably less efficient. The most common examples of non-contiguous memory access are loops with non-unit stride or with indirect addressing, as in the examples below. The compiler rarely vectorizes such loops, unless the amount of computational work is large compared to the overhead from non-contiguous memory access.</p><p><strong>Example: Non-contiguous Memory Access</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// arrays accessed with stride 2</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> I=<span class="number">0</span>; i&lt;SIZE; I+=<span class="number">2</span>) b[i] += a[i] * x[i];</div><div class="line"></div><div class="line"><span class="comment">// inner loop accesses a with stride SIZE</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;SIZE; j++) &#123;</div><div class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> I=<span class="number">0</span>; i&lt;SIZE; I++) b[i] += a[i][j] * x[j];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// indirect addressing of x using index array</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> I=<span class="number">0</span>; i&lt;SIZE; I+=<span class="number">2</span>) b[i] += a[i] * x[index[i]];</div></pre></td></tr></table></figure><p>The typical message from the vectorization report is: vectorization possible but seems inefficient, although indirect addressing may also result in the following report: Existence of vector dependence.</p><h2 id="Data-dependencies"><a href="#Data-dependencies" class="headerlink" title="Data dependencies"></a>Data dependencies</h2><p>Vectorization entails changes in the order of operations within a loop, since each SIMD instruction operates on several data elements at once. Vectorization is only possible if this change of order does not change the results of the calculation.</p><ol><li><p>The simplest case is when data elements that are written (stored to) do not appear in any other iteration of the individual loop. In this case, all the iterations of the original loop are independent of each other, and can be executed in any order, without changing the result. The loop may be safely executed using any parallel method, including vectorization. All the examples considered so far fall into<br>this category.</p></li><li><p>When a variable is written in one iteration and read in a subsequent iteration, there is a “read-afterwrite” dependency, also known as a flow dependency, as in this example:</p><p><strong>Example: Flow Dependency</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">A[<span class="number">0</span>]=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;MAX; j++) A[j]=A[j<span class="number">-1</span>]+<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// this is equivalent to:</span></div><div class="line">A[<span class="number">1</span>]=A[<span class="number">0</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">2</span>]=A[<span class="number">1</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">3</span>]=A[<span class="number">2</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">4</span>]=A[<span class="number">3</span>]+<span class="number">1</span>;</div></pre></td></tr></table></figure><p>So the value of <code>j</code> gets propagated to all <code>A[j]</code>. This cannot safely be vectorized: if the first two iterations are executed simultaneously by a SIMD instruction, the value of <code>A[1]</code> is used by the second iteration before it has been calculated by the first iteration.</p></li><li><p>When a variable is read in one iteration and written in a subsequent iteration, this is a write-after-read dependency, also known as an anti-dependency, as in the following example:</p><p><strong>Example: Write-after-read Dependency</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;MAX; j++) A[j<span class="number">-1</span>]=A[j]+<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">// this is equivalent to:</span></div><div class="line">A[<span class="number">0</span>]=A[<span class="number">1</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">1</span>]=A[<span class="number">2</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">2</span>]=A[<span class="number">3</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">3</span>]=A[<span class="number">4</span>]+<span class="number">1</span>;</div></pre></td></tr></table></figure><p>This write-after-read dependency is not safe for general parallel execution, since the iteration with the write may execute before the iteration with the read. However, for vectorization, no iteration with a higher value of <code>j</code> can complete before an iteration with a lower value of <code>j</code>, and so vectorization is safe (that is, it gives the same result as non-vectorized code) in this case. The following example, however, may not be safe, since vectorization might cause some elements of <code>A</code> to be overwritten by the first SIMD instruction before being used for the second SIMD instruction.</p><p><strong>Example: Unsafe Vectorization</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;MAX; j++) &#123;</div><div class="line">	A[j<span class="number">-1</span>]=A[j]+<span class="number">1</span>;</div><div class="line">	B[j]=A[j]*<span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// this is equivalent to:</span></div><div class="line">A[<span class="number">0</span>]=A[<span class="number">1</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">1</span>]=A[<span class="number">2</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">2</span>]=A[<span class="number">3</span>]+<span class="number">1</span>;</div><div class="line">A[<span class="number">3</span>]=A[<span class="number">4</span>]+<span class="number">1</span>;</div></pre></td></tr></table></figure></li><li><p>Read-after-read situations are not really dependencies, and do not prevent vectorization or parallel execution. If a variable is unwritten, it does not matter how often it is read.</p></li><li><p>Write-after-write, or ‘output’, dependencies, where the same variable is written to in more than one iteration, are in general unsafe for parallel execution, including vectorization.</p></li><li><p>One important exception, that apparently contains all of the above types of dependency:</p><p><strong>Example: Dependency Exception</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sum=<span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;MAX; j++) sum = sum + A[j]*B[j]</div></pre></td></tr></table></figure><p>Although sum is both read and written in every iteration, the compiler recognizes such reduction idioms, and is able to vectorize them safely. The loop in the first example was another example of a reduction, with a loop-invariant array element in place of a scalar.</p><p>These types of dependencies between loop iterations are sometimes known as loop-carried dependencies.</p><p>The above examples are of proven dependencies. The compiler cannot safely vectorize a loop if there is even a potential dependency. Consider the following example:</p><p><strong>Example: Potential Dependency</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; i++) &#123; c[i] = a[i] * b[i]; &#125;</div></pre></td></tr></table></figure><p>In the above example, the compiler needs to determine whether, for some iteration <code>i</code>, <code>c[i]</code> might refer to the same memory location as <code>a[i]</code> or <code>b[i]</code> for a different iteration. Such memory locations are sometimes said to be aliased. For example, if <code>a[i]</code> pointed to the same memory location as <code>c[i-1]</code>, there would be a read-after-write dependency as in the earlier example. If the compiler cannot exclude this possibility, it will not vectorize the loop unless you provide the compiler with hints.</p></li></ol><h1 id="Helping-the-Intel®-C-Compiler-to-Vectorize"><a href="#Helping-the-Intel®-C-Compiler-to-Vectorize" class="headerlink" title="Helping the Intel® C++ Compiler to Vectorize"></a>Helping the Intel® C++ Compiler to Vectorize</h1><p>Sometimes the Intel® C++ Compiler has insufficient information to decide to vectorize a loop. There are several ways to provide additional information to the compiler:</p><h2 id="Pragmas"><a href="#Pragmas" class="headerlink" title="Pragmas"></a>Pragmas</h2><ol><li><p><code>#pragma ivdep</code>: may be used to tell the compiler that it may safely ignore any potential data dependencies. (The compiler will not ignore proven dependencies). Use of this pragma when there are dependencies may lead to incorrect results.</p></li><li><p><code>#pragma loop count (n)</code>: may be used to advise the compiler of the typical trip count of the loop. This may help the compiler to decide whether vectorization is worthwhile, or whether or not it should generate alternative code paths for the loop.</p></li><li><p><code>#pragma vector always</code>: asks the compiler to vectorize the loop if it is safe to do so, whether or not the compiler thinks that will improve performance.</p></li><li><p><code>#pragma vector align</code>: asserts that data within the following loop is aligned (to a 16-byte boundary, for Intel® SSE instruction sets).</p></li><li><p><code>#pragma novector</code>: asks the compiler not to vectorize a particular loop.</p></li><li><p><code>#pragma vector nontemporal</code>: gives a hint to the compiler that data will not be reused, and therefore to use streaming stores that bypass cache.</p></li></ol><h2 id="Keywords"><a href="#Keywords" class="headerlink" title="Keywords"></a>Keywords</h2><p>The restrict keyword may be used to assert that the memory referenced by a pointer is not aliased, i.e. that it is not accessed in any other way. The keyword requires the use of either the <code>[Q]restrict</code> or <code>[Q]c99</code> compiler options.</p><p>The restrict qualifier in the argument list lets the compiler know that there are no other aliases to the memory to which the pointers point. In other words, the pointer for which it is used provides the only means of accessing the memory in question in the scope in which the pointers live. Even if the code gets vectorized without the restrict keyword, the compiler checks for aliasing at run-time, if the restrict keyword was used.</p><h2 id="Options-switches"><a href="#Options-switches" class="headerlink" title="Options/switches"></a>Options/switches</h2><p>You can use options to enable different levels of optimizations to achieve automatic vectorization:</p><ol><li><p><strong>Interprocedural optimization (IPO)</strong>: Enable IPO using <code>[Q]ip</code> option within a single source file, or using <code>[Q]ipo</code> across source files. You provide the compiler with additional information (trip counts, alignment, or data dependencies) about a loop. Enabling IPO may also allow inlining of function calls.</p></li><li><p><strong>Disambiguation of pointers and arrays</strong>: Use the options <code>/Oa</code> (Windows) or <code>–fno-alias</code> (Linux<em> or OS</em> X) to assert there is no aliasing of memory references, that is, the same memory location is not accessed via different arrays or pointers. Other options make more limited assertions, for example, <code>/Qalias-args-</code>(Windows) or <code>-fargument-noalias</code> (Linux<em> or OS X</em>) asserts that function arguments cannot alias each other (that is, they cannot overlap).</p><p>The <code>/Qansi-alias</code> (<code>-fargument-alias</code>) options allow the compiler to assume strict adherence to the aliasing rules in the ISO C standard. Use these options responsibly; if you use these options when memory is aliased it may lead to incorrect results.</p></li><li><p><strong>High-level optimizations (HLO)</strong>: Enable HLO with option <code>O3</code>. This will enable additional loop optimizations that make it easier for the compiler to vectorize the transformed loops. The HLO report, obtained using the <code>[Q]opt-report-phase[:]</code> loop option or the corresponding IDE selection, tells you whether some of these additional transformations occurred.</p></li></ol>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Application Optimization with Intel Compiler]]></title>
      <url>http://hamstersi.github.io/2017/07/Application-Optimization-with-Intel-Compiler/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="Application-Performance"><a href="#Application-Performance" class="headerlink" title="Application Performance:"></a>Application Performance:</h1><h2 id="A-Step-by-step-Approach-to-Tuning-Using-Intel-Compiler"><a href="#A-Step-by-step-Approach-to-Tuning-Using-Intel-Compiler" class="headerlink" title="A Step-by-step Approach to Tuning Using Intel Compiler:"></a>A Step-by-step Approach to Tuning Using Intel Compiler:</h2><p>Before you begin performance tuning, check correctness of your application by building it without optimization using <strong>/Od (-O0)</strong></p><ol><li>Measure performance using the general optimization options (Windows<em> <strong>/O1</strong>, <strong>/O2</strong> or <strong>/O3</strong>; Linux</em> and OS X<em> <strong>-O1</strong>, <strong>-O2</strong> and <strong>-O3</strong>) to see which works best for your application. Most users should start at <strong>/O2</strong> (<strong>-O2</strong>), the default, before trying more advanced optimizations. Nest, try <strong>/O3</strong> (<em>*-O3</em></em>) for the loop-intensive applications.</li><li>Fine-tune performance using processor-specific options such as <strong>/Qx (-x)</strong> or <strong>/arch (-m)</strong>. Examples are <strong>/QxCORE-AVX2 (-xcore-avx2)</strong> for the 4th generation Intel Core processor family and <strong>/arch:SSE3 (-msse3</strong>) for compatible, non-intel processors that support at least the Intel SSE3 instruction set. Or, <strong>/QxHOST (-xhost)</strong> will use the most advanced instruction set for the processor which you compiled.<a id="more"></a></li><li>Add interprocedural optimization (IPO), <strong>/Qipo (-ipo)</strong> and/or profile-guided optimization (PGO), <strong>/Qprof-gen</strong> and <strong>/Qprof-use (-prof-gen</strong> and <strong>-prof-use)</strong>, then measure performance again to determine whether your application benefits from one or both of them.</li><li>Use Intel VTune Amplifier to help you identify serial and parallel performance hotspots within your application that could benefit from further performance tuning. Use the compiler optimization report <strong>/Qopt-report (-qopt-report)</strong> to help identify individual optimization opportunities.</li><li>Further optimize your application for SIMD through explicit vector programming using the Intel Cilk Plus language extensions for C/C++ or the SIMD features of OpenMP with <strong>/Qopenmp-simd (-qopenmp-simd)</strong>.</li><li>Optimize for parallel execution on multithreaded, multicore, and multiprocessor systems using the auto-parallelization option <strong>/Qparallel (-parallel)</strong>; the Intel Cilk Plus language extensions for C/C++; OpenMP pragmas or directives along with the option <strong>/Qopenmp (-qopenmp)</strong>; or by using the Intel Performance Libraries included with the product. Use Intel Inspector to reduce the time to market for threaded application by diagnosing memory and threading errors and speeding up the development process.</li></ol><h1 id="Compiler-Options"><a href="#Compiler-Options" class="headerlink" title="Compiler Options"></a>Compiler Options</h1><h2 id="General-Optimization-Options"><a href="#General-Optimization-Options" class="headerlink" title="General Optimization Options"></a>General Optimization Options</h2><p><img src="http://wx1.sinaimg.cn/large/672d88aagy1fickvmbknej21yu2jotub.jpg" alt="General Optimization Options"></p><h2 id="Parallel-Performance"><a href="#Parallel-Performance" class="headerlink" title="Parallel Performance"></a>Parallel Performance</h2><p><img src="http://wx3.sinaimg.cn/large/672d88aagy1fickvokkfrj21yu2joh7g.jpg" alt="Parallel Performance"></p><h2 id="Parallel-Performance-Using-Intel®-CilkTM-Plus"><a href="#Parallel-Performance-Using-Intel®-CilkTM-Plus" class="headerlink" title="Parallel Performance Using Intel® CilkTM Plus"></a>Parallel Performance Using Intel® CilkTM Plus</h2><p><img src="http://wx3.sinaimg.cn/large/672d88aagy1fickvr66ucj21yu2jox3w.jpg" alt="Parallel Performance Using Intel® CilkTM Plus"></p><h2 id="Recommended-Processor-Specific-Optimization-Options"><a href="#Recommended-Processor-Specific-Optimization-Options" class="headerlink" title="Recommended Processor-Specific Optimization Options"></a>Recommended Processor-Specific Optimization Options</h2><p><img src="http://wx1.sinaimg.cn/large/672d88aagy1fickvtvjb0j21yu2joayx.jpg" alt="Recommended Processor-Specific Optimization Options"></p><h2 id="Compiling-for-Offload"><a href="#Compiling-for-Offload" class="headerlink" title="Compiling for Offload"></a>Compiling for Offload</h2><h2 id="Compiling-for-Intel®-Graphics-Technology"><a href="#Compiling-for-Intel®-Graphics-Technology" class="headerlink" title="Compiling for Intel® Graphics Technology"></a>Compiling for Intel® Graphics Technology</h2><h2 id="Environment-Variables-for-Intel®-Graphics-Technology"><a href="#Environment-Variables-for-Intel®-Graphics-Technology" class="headerlink" title="Environment Variables for Intel® Graphics Technology"></a>Environment Variables for Intel® Graphics Technology</h2><p><img src="http://wx1.sinaimg.cn/large/672d88aagy1fickvwijz8j21yu2joh9v.jpg" alt="Compiling for Offload"></p><h2 id="Optimizing-for-the-Intel®-Xeon-PhiTM-Coprocessor-x100-product-family"><a href="#Optimizing-for-the-Intel®-Xeon-PhiTM-Coprocessor-x100-product-family" class="headerlink" title="Optimizing for the Intel® Xeon PhiTM Coprocessor x100 product family"></a>Optimizing for the Intel® Xeon PhiTM Coprocessor x100 product family</h2><h2 id="Environment-Variables-for-the-Intel®-Xeon-PhiTM-Coprocessor"><a href="#Environment-Variables-for-the-Intel®-Xeon-PhiTM-Coprocessor" class="headerlink" title="Environment Variables for the Intel® Xeon PhiTM Coprocessor"></a>Environment Variables for the Intel® Xeon PhiTM Coprocessor</h2><p><img src="http://wx1.sinaimg.cn/large/672d88aagy1fickvze1opj21yu2jonp4.jpg" alt="Compiling for Intel® Graphics Technology"></p><h2 id="Interprocedural-Optimization-IPO-and-Profile-Guided-Optimization-PGO-Options"><a href="#Interprocedural-Optimization-IPO-and-Profile-Guided-Optimization-PGO-Options" class="headerlink" title="Interprocedural Optimization (IPO) and Profile-Guided Optimization (PGO) Options"></a>Interprocedural Optimization (IPO) and Profile-Guided Optimization (PGO) Options</h2><p><img src="http://wx2.sinaimg.cn/large/672d88aagy1fickw17u5pj21yu2joqlx.jpg" alt="Interprocedural Optimization (IPO) and Profile-Guided Optimization (PGO) Options"></p><h2 id="Floating-Point-Arithmetic-Options"><a href="#Floating-Point-Arithmetic-Options" class="headerlink" title="Floating-Point Arithmetic Options"></a>Floating-Point Arithmetic Options</h2><p><img src="http://wx4.sinaimg.cn/large/672d88aagy1fickw3vlqbj21yu2joe37.jpg" alt="Floating-Point Arithmetic Options"></p><h2 id="Fine-Tuning-All-Processors"><a href="#Fine-Tuning-All-Processors" class="headerlink" title="Fine-Tuning (All Processors)"></a>Fine-Tuning (All Processors)</h2><p><img src="http://wx4.sinaimg.cn/large/672d88aagy1fickw6igwxj21yu2joqt0.jpg" alt="Fine-Tuning (All Processors)"></p><h2 id="Debug-Options"><a href="#Debug-Options" class="headerlink" title="Debug Options"></a>Debug Options</h2><h2 id="Optimization-Notice"><a href="#Optimization-Notice" class="headerlink" title="Optimization Notice"></a>Optimization Notice</h2><p><img src="http://wx3.sinaimg.cn/large/672d88aagy1fickw912xpj21yu2jo1ge.jpg" alt="Debug Options"></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2017-06 Ice Green]]></title>
      <url>http://hamstersi.github.io/2017/06/2017-06%20Ice%20Green/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width:50%"><img src="http://wx1.sinaimg.cn/mw690/672d88aagy1fihd2r8pu0j21kw11ve88.jpg" alt="Ice &amp; Green"></div><div class="group-picture-column" style="width:50%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fievyjfdh9j238o25se85.jpg" alt="Ice &amp; Green"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width:50%"><img src="http://wx4.sinaimg.cn/mw690/672d88aagy1fihdhmu2pxj238o25sx6q.jpg" alt="Ice &amp; Green"></div><div class="group-picture-column" style="width:50%"><img src="http://wx1.sinaimg.cn/mw690/672d88aagy1fihd4zamipj21kw11x4qs.jpg" alt="Ice &amp; Green"></div></div></div></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[GCC常用命令简介]]></title>
      <url>http://hamstersi.github.io/2017/06/GCC%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="GCC简介"><a href="#GCC简介" class="headerlink" title="GCC简介"></a>GCC简介</h1><p>GCC 的意思也只是 GNU C Compiler 而已。经过了这么多年的发展，GCC 已经不仅仅能支持 C 语言；它现在还支持 Ada 语言、C++ 语言、Java 语言、Objective C 语言、Pascal 语言、COBOL语言，以及支持函数式编程和逻辑编程的 Mercury 语言，等等。而 GCC 也不再单只是 GNU C 语言编译器的意思了，而是变成了 GNU Compiler Collection 也即是 GNU 编译器家族的意思了。另一方面，说到 GCC 对于操作系统平台及硬件平台支持，概括起来就是一句话：无所不在。</p><h1 id="简单编译"><a href="#简单编译" class="headerlink" title="简单编译"></a>简单编译</h1><p>示例程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//test.c</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><a id="more"></a><p>这个程序，一步到位的编译指令是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.c -o test</div></pre></td></tr></table></figure><p>实质上，上述编译过程是分为四个阶段进行的，即预处理(也称预编译，Preprocessing)、编译(Compilation)、汇编 (Assembly)和连接(Linking)。</p><h2 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -E test.c -o test.i 或 gcc -E test.c</div></pre></td></tr></table></figure><p>可以输出test.i文件中存放着test.c经预处理之后的代码。打开test.i文件，看一看，就明白了。后面那条指令，是直接在命令行窗口中输出预处理后的代码.</p><p>gcc的-E选项，可以让编译器在预处理后停止，并输出预处理结果。在本例中，预处理结果就是将stdio.h 文件中的内容插入到test.c中了。</p><h2 id="编译为汇编代码-Compilation"><a href="#编译为汇编代码-Compilation" class="headerlink" title="编译为汇编代码(Compilation)"></a>编译为汇编代码(Compilation)</h2><p>预处理之后，可直接对生成的test.i文件编译，生成汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -S test.i -o test.s</div></pre></td></tr></table></figure><p>gcc的-S选项，表示在程序编译期间，在生成汇编代码后，停止，-o输出汇编代码文件。</p><h2 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly)"></a>汇编(Assembly)</h2><p>对于上一小节中生成的汇编代码文件test.s，gas汇编器负责将其编译为目标文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -c test.s -o test.o</div></pre></td></tr></table></figure><h2 id="连接-Linking"><a href="#连接-Linking" class="headerlink" title="连接(Linking)"></a>连接(Linking)</h2><p>gcc连接器是gas提供的，负责将程序的目标文件与所需的所有附加的目标文件连接起来，最终生成可执行文件。附加的目标文件包括静态连接库和动态连接库。</p><p>对于上一小节中生成的test.o，将其与Ｃ标准输入输出库进行连接，最终生成程序test</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc test.o -o test</div></pre></td></tr></table></figure><p>在命令行窗口中，执行./test, 让它说HelloWorld吧！</p><h1 id="多个程序文件的编译"><a href="#多个程序文件的编译" class="headerlink" title="多个程序文件的编译"></a>多个程序文件的编译</h1><p>通常整个程序是由多个源文件组成的，相应地也就形成了多个编译单元，使用GCC能够很好地管理这些编译单元。假设有一个由test1.c和 test2.c两个源文件组成的程序，为了对它们进行编译，并最终生成可执行程序test，可以使用下面这条命令：</p><p>gcc test1.c test2.c -o test</p><p>如果同时处理的文件不止一个，GCC仍然会按照预处理、编译和链接的过程依次进行。如果深究起来，上面这条命令大致相当于依次执行如下三条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -c test1.c -o test1.o</div><div class="line">gcc -c test2.c -o test2.o</div><div class="line">gcc test1.o test2.o -o test</div></pre></td></tr></table></figure><h1 id="检错"><a href="#检错" class="headerlink" title="检错"></a>检错</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -pedantic illcode.c -o illcode</div></pre></td></tr></table></figure><p>-pedantic编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，-pedantic选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p><p>除了-pedantic之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数-Wall了，使用它能够使GCC产生尽可能多的警告信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Wall illcode.c -o illcode</div></pre></td></tr></table></figure><p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -Werror test.c -o test</div></pre></td></tr></table></figure><h1 id="库文件连接"><a href="#库文件连接" class="headerlink" title="库文件连接"></a>库文件连接</h1><p>开发软件时，完全不使用第三方函数库的情况是比较少见的，通常来讲都需要借助许多函数库的支持才能够完成相应的功能。从程序员的角度看，函数库实际上就是一些头文件（.h）和库文件（so、或lib、dll）的集合。。虽然Linux下的大多数函数都默认将头文件放到/usr/include/目录下，而库文件则放到/usr/lib/目录下；Windows所使用的库文件主要放在Visual Stido的目录下的include和lib，以及系统文件夹下。但也有的时候，我们要用的库不再这些目录下，所以GCC在编译时必须用自己的办法来查找所需要的头文件和库文件。</p><p>例如我们的程序test.c是在linux上使用c连接mysql，这个时候我们需要去mysql官网下载MySQL Connectors的C库，下载下来解压之后，有一个include文件夹，里面包含mysql connectors的头文件，还有一个lib文件夹，里面包含二进制so文件libmysqlclient.so</p><p>其中inclulde文件夹的路径是/usr/dev/mysql/include,lib文件夹是/usr/dev/mysql/lib</p><h2 id="编译成可执行文件"><a href="#编译成可执行文件" class="headerlink" title="编译成可执行文件"></a>编译成可执行文件</h2><p>首先我们要进行编译test.c为目标文件，这个时候需要执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –c –I /usr/dev/mysql/include test.c –o test.o</div></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>最后我们把所有目标文件链接成可执行文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –lmysqlclient test.o –o test</div></pre></td></tr></table></figure><p>Linux下的库文件分为两大类分别是动态链接库（通常以.so结尾）和静态链接库（通常以.a结尾），二者的区别仅在于程序执行时所需的代码是在运行时动态加载的，还是在编译时静态加载的。</p><h2 id="强制链接时使用静态链接库"><a href="#强制链接时使用静态链接库" class="headerlink" title="强制链接时使用静态链接库"></a>强制链接时使用静态链接库</h2><p>默认情况下， GCC在链接时优先使用动态链接库，只有当动态链接库不存在时才考虑使用静态链接库，如果需要的话可以在编译时加上-static选项，强制使用静态链接库。</p><p>在/usr/dev/mysql/lib目录下有链接时所需要的库文件libmysqlclient.so和libmysqlclient.a，为了让GCC在链接时只用到静态链接库，可以使用下面的命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc –L /usr/dev/mysql/lib –static –lmysqlclient test.o –o test</div></pre></td></tr></table></figure><p>静态库链接时搜索路径顺序：</p><ol><li>ld会去找GCC命令中的参数-L</li><li>再找gcc的环境变量LIBRARY_PATH</li><li>再找内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li></ol><p>动态链接时、执行时搜索路径顺序:</p><ol><li>编译目标代码时指定的动态库搜索路径</li><li>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</li><li>配置文件/etc/ld.so.conf中指定的动态库搜索路径</li><li>默认的动态库搜索路径/lib</li><li>默认的动态库搜索路径/usr/lib</li></ol><p>有关环境变量：<br>LIBRARY_PATH环境变量：指定程序静态链接库文件搜索路径<br>LD_LIBRARY_PATH环境变量：指定程序动态链接库文件搜索路径</p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[水鬼与夏天的葬礼]]></title>
      <url>http://hamstersi.github.io/2017/06/%E6%B0%B4%E9%AC%BC%E4%B8%8E%E5%A4%8F%E5%A4%A9%E7%9A%84%E8%91%AC%E7%A4%BC/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h2 id="水鬼"><a href="#水鬼" class="headerlink" title="-水鬼-"></a>-水鬼-</h2><p><img src="http://wx3.sinaimg.cn/mw690/672d88aagy1fibem5ku6wj21c50u3qad.jpg" alt="百鬼夜行"></p><div id="aplayer1" class="aplayer" style="margin-bottom:20px;width:99%"></div><script>new APlayer({element:document.getElementById("aplayer1"),narrow:!1,autoplay:!1,showlrc:0,music:{title:"百鬼夜行抄~序章",author:"森英治",url:"http://link.hhtjim.com/xiami/3502285.mp3",pic:"http://wx2.sinaimg.cn/large/672d88aagy1fibfds8mddj20fz0fwas9.jpg"}})</script><p>河里是有水鬼的。</p><p>那是一种身体类似蟒蛇，长有两只手的生物，全身上下布满绿色的腐皮和水泡，长着或尖锐或锈钝的金属牙齿，眼睛会发出橙黄色的荧光。眼角旁生着两条又细又长的绿色须毛，水鬼靠长须在水中游动。<br><a id="more"></a><br>不论如何，你若是遇上了，就是死路一条。他们可以喷出携带剧毒的黏液，或是直接用牙齿啃咬你瘦弱的肌骨。拖至河里吞食。</p><p>水鬼也不是必须要吃东西的，他们光靠水面上的浮萍和水葫芦也一样能生存地好好地。但是人的血液、骨肉、毛发，是他们的营养品。绝不如浮萍和水葫芦那般嚼着青涩无味，而是又腥又甜，甘醇香厚。噬一口能产生美妙的幻像，那是令水鬼颤栗的甜品。</p><p>所以他们从原本藏匿的淤泥石块里钻出来，潜伏在石岸边。有时候会突然从深绿色的河面里伸出皱皱巴巴如干尸般的绿手，迅速将你拽入水中，美餐一顿。</p><p>他们最喜爱吃幼童。幼童的肉体嫩滑软糯，毛发乌黑柔顺，连小指甲都是光滑干净的。他们的心脏里没像成人，暗埋着诸多阴险与贪念，人类肮脏污秽的本性，在他们身上还未完全发育好。</p><p>水鬼不喜欢阳光，像他们那样做着偷窃行为的强盗，是不能见光的。不是生理上的禁止，是精神上的。若是在那样明晃晃的光线下，水鬼会感觉全身上下的一切都被他人探照地完完全全。他们有头脑，然而又单细胞。明明所有人都晓得他们那点儿勾当，他们还认为一切是自己悄悄策划的私人秘密。其实如若碰到阳光，他们顶多是觉着眼睛酸痛，晒掉点儿死皮。</p><p>他们是群体，共生共存，观念和智商也一起进步着，或退化着。品性和爱好也如此。他们不能单独行动一片河域，即使有再多的人肉资源，如果水鬼单独生活，也活不过2天。但他们又是个体，因为自私的他们不愿意将自己辛苦得手的猎物让与其他渴望的同类。有些水鬼，一生都吃不着一个人，有些水鬼，日日夜夜口腔都浸泡在腥甜的人类血液之中。</p><p>水鬼群体不会永远只驻留在一个村庄，他们会分流，分群，各奔东西。也会在偶然的一天汇聚在一起，不论如何，他们都是同类，都是一起存活着相同的生物。他们互相憎恶着，嫉妒着，嘲笑着。呼吸着不同的空气，但生活在同样的腐朽的世界。</p><p>水鬼不是没有善良过的。</p><p>他们曾经驻留在深深的河水泥层里，与黑暗作伴，他们的思维却未曾被黑暗涤荡，他们总是在夜深人静的黑夜浮出水面，望望月亮，望望星星，望望夜灯，吹一吹凉爽的风，听一听昆虫的低语。采一朵青嫩的浮萍，游入自己的小窝静静啃啮。那个时候，水鬼没有那么泛滥。</p><p>他们甚至有一种帮助人类的本职，如果有孩子不慎坠入河里，他们会第一时间赶到然后迅速将孩子们送到岸边，确认无危险之后才肯离去。</p><p>但是他们时常被大人们追逐着伤害。</p><p>“那他妈是什么鬼东西！？”有些人见水鬼可怕的模样就抄起家伙狠狠揍一顿。水鬼通常挨这一顿揍，就离死不远了。</p><p>明明水鬼那么努力地隐藏自己，又那么努力地保护人类。</p><p>人类还是怀着恶意去探索，只因为他人口中的传言。他们见到水鬼了，兴奋又害怕，打死水鬼了，就产生一种满满的自豪感。人类总是缺少茶余饭后的谈资，因此不断挖掘他们心中所认为的丑恶，来体现智慧和丰满的天性。</p><p>所以水鬼变了。</p><p>坏一点儿，也没什么不好，再他们吃了第一具人类的躯体之后，他们这么想。</p><p>终于，那被数代水鬼压抑了几百年的黑暗细胞触及到滚烫的血液，猛烈地燃烧了，燃烧过后残存的黑色灰烬与骸骨，便是如今的他们所携带的品性。</p><p>但水鬼还是清清楚楚知道的，自己所做的一切都是邪恶的，可怕的。不像那么些人类，做着愚昧荒淫的事儿，还心安理得。</p><p>人类伤害着水鬼，水鬼伤害着人类，</p><p>人类和水鬼，或许也是相互依存的。</p><h2 id="夏天是一场葬礼"><a href="#夏天是一场葬礼" class="headerlink" title="夏天是一场葬礼"></a>夏天是一场葬礼</h2><p>它烹煮了一汪汤水，混搅了夏虫透而薄的翅子，森林之中斑驳的凉阴，浮于河滩之上细碎的光晕，全都在温度之中沸腾了，这是缄默的仪式，这是圣水。</p><p>夏蝉伏在古树虬结了细茎与疮痂的皮层上，不休不眠哀悼着，即便是并不庄严的喉咙，扰人的聒噪里夹杂着凄寂，在黎明的骤冷里化为动也不动的另一具具尸骸，和梗塞了的冷却的声音一起，被土壤掩埋。这是奏响的哀歌。</p><p>以及墓地，什么是墓地。哪里可以埋葬整整一个繁华的春天，流淌着化雪的河水，三更夜里杏雨拂窗，梨云遮月，桃花映面，堆砌起一整个春天。</p><p>地面才浓抹了胭脂水粉，却等那白驹走完这条巷道，又要被圣水洗去。</p><p>但是夏光，会为它画眉。</p><p>烈日将它焚成了灰，烟花祭的夜晚盛放。</p><p>然后海潮，卷起最后的遗灰。</p><p>春天的灵魂就在黄昏里飞走了。</p><p>等秋天来了，冬天过去。</p><blockquote><p><a href="http://fjisheng.lofter.com" target="_blank" rel="external"><strong>LOFTER: Poem-</strong></a></p></blockquote>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2014 - 09 New Brighton @ Christchurch.md]]></title>
      <url>http://hamstersi.github.io/2017/03/2014-09-New-Brighton-@-Christchurch/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width:50%"><img src="http://wx4.sinaimg.cn/large/672d88aagy1fd8uvir0alj23b41v0npd.jpg" alt="New Brighton @ Christchurch"></div><div class="group-picture-column" style="width:50%"><img src="http://wx1.sinaimg.cn/mw690/672d88aagy1fd8uv0rhn8j23b41v0npd.jpg" alt="New Brighton @ Christchurch"></div></div><div class="group-picture-row"><div class="group-picture-column" style="width:50%"><img src="http://wx1.sinaimg.cn/mw690/672d88aagy1fd8uvdjjyyj23b41v0e81.jpg" alt="New Brighton @ Christchurch"></div><div class="group-picture-column" style="width:50%"><img src="http://wx2.sinaimg.cn/mw690/672d88aagy1fd8uuw8bghj23b41v0kjl.jpg" alt="New Brighton @ Christchurch"></div></div></div></div>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CPU Metrics Reference - General Exploration]]></title>
      <url>http://hamstersi.github.io/2017/03/CPU-Metrics-Reference-General-Exploration/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>To make your applications take advantage of CPU microarchitectures, you need to know how the application is utilizing available hardware resources. One way to obtain this knowledge is by using on-chip Performance Monitoring Units (PMUs). PMUs are dedicated pieces of logic within a CPU core that count specific hardware events as they occur on the system. Examples of these events may be Cache Misses or Branch Mispredictions. These events can be observed and combined to create useful high-level metrics such as Cycles per Instruction (CPI).</p><a id="more"></a><p><img src="http://wx1.sinaimg.cn/mw690/672d88aagy1fd8s0n9jsqj219r0c4n00.jpg" alt="Pipeline"></p><p>The pipeline of a modern high-performance CPU is quite complex. In the simplified view blow, the pipeline is divided conceptually into two halves, the Front-end and the Back-end. The Front-end is responsible for fetching the program code represented in architectural instructions and decoding them into one or more low-level hardware operations called <em>micro-ops</em> (uOps). The uOps are then fed to the Back-end in a process called <em>allocation</em>. Once allocated, the Back-end is responsible for monitoring when uOp’s data operands are available and executing the uOp in an available execution unit. The completion of a uOp’s execution is called <em>retirement</em>, and is where results of the uOp are committed to the architectural state (CPU registers or written back to memory). Usually, most uOps pass completely through the pipeline and retire, but sometimes speculatively fetched uOps may get cancelled before retirement – like in the case of mispredicted branches.<br><img src="http://wx4.sinaimg.cn/large/672d88aagy1fd8sap5wrqg20xc0h2jsp.gif" alt="uOp Categories"></p><h1 id="Front-End-Bound"><a href="#Front-End-Bound" class="headerlink" title="Front-End Bound"></a>Front-End Bound</h1><p>Superscalar processors can be conceptually divided into the ‘front-end’, where instructions are fetched and decoded into the operations that constitute them; and the ‘back-end’, where the required computation is performed. Each cycle, the front-end generates up to four of these operations placed into pipeline slots that then move through the back-end. Thus, for a given execution duration in clock cycles, it is easy to determine the maximum number of pipeline slots containing useful work that can be retired in that duration. The actual number of retired pipeline slots containing useful work, though, rarely equals this maximum. This can be due to several factors: some pipeline slots cannot be filled with useful work, either because the front-end could not fetch or decode instructions in time (‘Front-end bound’ execution) or because the back-end was not prepared to accept more operations of a certain kind (‘Back-end bound’ execution). Moreover, even pipeline slots that do contain useful work may not retire due to bad speculation. Front-end bound execution may be due to a large code working set, poor code layout, or microcode assists. Back-end bound execution may be due to long-latency operations or other contention for execution resources. Bad speculation is most frequently due to branch misprediction.</p><p>A significant proportion of pipeline slots are remaining empty. Possible reasons include a large code working size, poor code layout (requiring too many memory accesses per cycle to get sufficient instructions to fill four pipeline slots), or microcode assists.</p><h2 id="gt-Front-End-Latency"><a href="#gt-Front-End-Latency" class="headerlink" title="&gt; Front-End Latency"></a>&gt; Front-End Latency</h2><p>This metric represents a fraction of slots during which CPU was stalled due to front-end latency issues, such as instruction-cache misses, ITLB misses or fetch stalls after a branch misprediction. In such cases, the front-end delivers no uOps.</p><h3 id="gt-gt-ICache-Misses"><a href="#gt-gt-ICache-Misses" class="headerlink" title="&gt;&gt; ICache Misses"></a>&gt;&gt; ICache Misses</h3><p>To introduce new uOps into the pipeline, the core must either fetch them from a decoded instruction cache, or fetch the instructions themselves from memory and then decode them. In the latter path, the requests to memory first go through the L1I (level 1 instruction) cache that caches the recent code working set. Front-end stalls can accrue when fetched instructions are not present in the L1I. Possible reasons are a large code working set or fragmentation between hot and cold code. In the latter case, when a hot instruction is fetched into the L1I, any cold code on its cache line is brought along with it. This may result in the eviction of other, hotter code.</p><h3 id="gt-gt-ITLB-Overhead"><a href="#gt-gt-ITLB-Overhead" class="headerlink" title="&gt;&gt; ITLB Overhead"></a>&gt;&gt; ITLB Overhead</h3><p>In x86 architectures, mappings between virtual and physical memory are facilitated by a page table, which is kept in memory. To minimize references to this table, recently-used portions of the page table are cached in a hierarchy of ‘translation look-aside buffers’, or TLBs, which are consulted on every virtual address translation. As with data caches, the farther a request has to go to be satisfied, the worse the performance impact. This metric estimates the performance penalty of page walks induced on ITLB (instruction TLB) misses.</p><h3 id="gt-gt-Branch-Resteers"><a href="#gt-gt-Branch-Resteers" class="headerlink" title="&gt;&gt; Branch Resteers"></a>&gt;&gt; Branch Resteers</h3><p>This metric represents cycles fraction the CPU was stalled due to Branch Resteers. Branch Resteers estimates the Frontend delay in fetching operations from corrected path, following all sorts of mispredicted branches. For example, branchy code with lots of misprediction might get categorized under Branch Resteers. Note the value of this node may overlap with its siblings.</p><h3 id="gt-gt-DSB-Switches"><a href="#gt-gt-DSB-Switches" class="headerlink" title="&gt;&gt; DSB Switches"></a>&gt;&gt; DSB Switches</h3><p>Intel microarchitecture code name Sandy Bridge introduces a new decoded ICache. This cache, called the DSB (Decoded Stream Buffer), stores uOps that have already been decoded, avoiding many of the penalties of the legacy decode pipeline, called the MITE (Micro-instruction Translation Engine). However, when control flows out of the region cached in the DSB, the front-end incurs a penalty as uOp issue switches from the DSB to the MITE. This metric measures this penalty.</p><h3 id="gt-gt-Length-Changing-Prefixes"><a href="#gt-gt-Length-Changing-Prefixes" class="headerlink" title="&gt;&gt; Length Changing Prefixes"></a>&gt;&gt; Length Changing Prefixes</h3><p>This metric represents a fraction of cycles during which CPU was stalled due to Length Changing Prefixes (LCPs). To avoid this issue, use proper compiler flags. Intel Compiler enables these flags by default.</p><h3 id="gt-gt-MS-Switches"><a href="#gt-gt-MS-Switches" class="headerlink" title="&gt;&gt; MS Switches"></a>&gt;&gt; MS Switches</h3><p>This metric represents a fraction of cycles when the CPU was stalled due to switches of uOp delivery to the Microcode Sequencer (MS). Commonly used instructions are optimized for delivery by the DSB or MITE pipelines. Certain operations cannot be handled natively by the execution pipeline, and must be performed by microcode (small programs injected into the execution stream). Switching to the MS too often can negatively impact performance. The MS is designated to deliver long uOp flows required by CISC instructions like CPUID, or uncommon conditions like Floating Point Assists when dealing with Denormals.</p><h2 id="gt-Front-End-Bandwidth"><a href="#gt-Front-End-Bandwidth" class="headerlink" title="&gt; Front-End Bandwidth"></a>&gt; Front-End Bandwidth</h2><p>This metric represents a fraction of slots during which CPU was stalled due to front-end bandwidth issues, such as inefficiencies in the instruction decoders or code restrictions for caching in the DSB (decoded uOps cache). In such cases, the front-end typically delivers a non-optimal amount of uOps to the back-end.</p><h3 id="gt-gt-Front-End-Bandwidth-MITE"><a href="#gt-gt-Front-End-Bandwidth-MITE" class="headerlink" title="&gt;&gt; Front-End Bandwidth MITE"></a>&gt;&gt; Front-End Bandwidth MITE</h3><p>This metric represents a fraction of cycles during which CPU was stalled due to the MITE fetch pipeline issues, such as inefficiencies in the instruction decoders.</p><h3 id="gt-gt-Front-End-Bandwidth-DSB"><a href="#gt-gt-Front-End-Bandwidth-DSB" class="headerlink" title="&gt;&gt; Front-End Bandwidth DSB"></a>&gt;&gt; Front-End Bandwidth DSB</h3><p>This metric represents a fraction of cycles during which CPU was likely limited due to DSB (decoded uOp cache) fetch pipeline. For example, inefficient utilization of the DSB cache structure or bank conflict when reading from it, are categorized here.</p><h3 id="gt-gt-Front-End-Bandwidth-LSD"><a href="#gt-gt-Front-End-Bandwidth-LSD" class="headerlink" title="&gt;&gt; Front-End Bandwidth LSD"></a>&gt;&gt; Front-End Bandwidth LSD</h3><p>This metric represents a fraction of cycles during which CPU operation was limited by the LSD (Loop Stream Detector) unit. Typically, LSD provides good uOp supply. However, in some rare cases, optimal uOp delivery cannot be reached for small loops whose size (in terms of number of uOps) does not suit well the LSD structure.</p><h1 id="Bad-Speculation"><a href="#Bad-Speculation" class="headerlink" title="Bad Speculation"></a>Bad Speculation</h1><h2 id="gt-Branch-Mispredict"><a href="#gt-Branch-Mispredict" class="headerlink" title="&gt; Branch Mispredict"></a>&gt; Branch Mispredict</h2><p>When a branch mispredicts, some instructions from the mispredicted path still move through the pipeline. All work performed on these instructions is wasted since they would not have been executed had the branch been correctly predicted. This metric represents slots fraction the CPU has wasted due to Branch Misprediction. These slots are either wasted by uOps fetched from an incorrectly speculated program path, or stalls when the out-of-order part of the machine needs to recover its state from a speculative path.</p><h2 id="gt-Machine-Clears"><a href="#gt-Machine-Clears" class="headerlink" title="&gt; Machine Clears"></a>&gt; Machine Clears</h2><p>Certain events require the entire pipeline to be cleared and restarted from just after the last retired instruction. This metric measures three such events: memory ordering violations, self-modifying code, and certain loads to illegal address ranges. Machine Clears metric represents slots fraction the CPU has wasted due to Machine Clears. These slots are either wasted by uOps fetched prior to the clear, or stalls the out-of-order portion of the machine needs to recover its state after the clear.</p><h1 id="Back-End-Bound"><a href="#Back-End-Bound" class="headerlink" title="Back-End Bound"></a>Back-End Bound</h1><p>Identify slots where no uOps are delivered due to a lack of required resources for accepting more uOps in the back-end of the pipeline. Back-end metrics describe a portion of the pipeline where the out-of-order scheduler dispatches ready uOps into their respective execution units, and, once completed, these uOps get retired according to program order. Stalls due to data-cache misses or stalls due to the overloaded divider unit are examples of back-end bound issues.</p><h2 id="gt-Memory-Bound"><a href="#gt-Memory-Bound" class="headerlink" title="&gt; Memory Bound"></a>&gt; Memory Bound</h2><p>This metric shows how memory subsystem issues affect the performance. Memory Bound measures a fraction of slots where pipeline could be stalled due to demand load or store instructions. This accounts mainly for incomplete in-flight memory demand loads that coincide with execution starvation in addition to less common cases where stores could imply back-pressure on the pipeline.</p><h3 id="gt-gt-L1-Bound"><a href="#gt-gt-L1-Bound" class="headerlink" title="&gt;&gt; L1 Bound"></a>&gt;&gt; L1 Bound</h3><p>This metric shows how often machine was stalled without missing the L1 data cache. The L1 cache typically has the shortest latency. However, in certain cases like loads blocked on older stores, a load might suffer a high latency even though it is being satisfied by the L1.</p><h4 id="gt-gt-gt-DTLB-Overhead"><a href="#gt-gt-gt-DTLB-Overhead" class="headerlink" title="&gt;&gt;&gt; DTLB Overhead"></a>&gt;&gt;&gt; DTLB Overhead</h4><p>This metric estimates the performance penalty paid for missing the first-level data TLB (DTLB) that includes hitting in the second-level data TLB (STLB) as well as performing a hardware page walk on an STLB miss.</p><h4 id="gt-gt-gt-Loads-Blocked-by-Store-Forwarding"><a href="#gt-gt-gt-Loads-Blocked-by-Store-Forwarding" class="headerlink" title="&gt;&gt;&gt; Loads Blocked by Store Forwarding"></a>&gt;&gt;&gt; Loads Blocked by Store Forwarding</h4><p>To streamline memory operations in the pipeline, a load can avoid waiting for memory if a prior store, still in flight, is writing the data that the load wants to read (a ‘store forwarding’ process). However, in some cases, generally when the prior store is writing a smaller region than the load is reading, the load is blocked for a significant time pending the store forward. This metric measures the performance penalty of such blocked loads.</p><h4 id="gt-gt-gt-Lock-Latency"><a href="#gt-gt-gt-Lock-Latency" class="headerlink" title="&gt;&gt;&gt; Lock Latency"></a>&gt;&gt;&gt; Lock Latency</h4><p>This metric represents cycles fraction the CPU spent handling cache misses due to lock operations. Due to the microarchitecture handling of locks, they are classified as L1 Bound regardless of what memory source satisfied them.</p><h4 id="gt-gt-gt-Split-Loads"><a href="#gt-gt-gt-Split-Loads" class="headerlink" title="&gt;&gt;&gt; Split Loads"></a>&gt;&gt;&gt; Split Loads</h4><p>Throughout the memory hierarchy, data moves at cache line granularity - 64 bytes per line. Although this is much larger than many common data types, such as integer, float, or double, unaligned values of these or other types may span two cache lines. Recent Intel architectures have significantly improved the performance of such ‘split loads’ by introducing split registers to handle these cases, but split loads can still be problematic, especially if many split loads in a row consume all available split registers.</p><h4 id="gt-gt-gt-4K-Aliasing"><a href="#gt-gt-gt-4K-Aliasing" class="headerlink" title="&gt;&gt;&gt; 4K Aliasing"></a>&gt;&gt;&gt; 4K Aliasing</h4><p>When an earlier (in program order) load issued after a later (in program order) store, a potential WAR (write-after-read) hazard exists. To detect such hazards, the memory order buffer (MOB) compares the low-order 12 bits of the load and store in every potential WAR hazard. If they match, the load is reissued, penalizing performance. However, as only 12 bits are compared, a WAR hazard may be detected falsely on loads and stores whose addresses are separated by a multiple of 4096 (2^12). This metric estimates the performance penalty of handling such falsely aliasing loads and stores.</p><h4 id="gt-gt-gt-FB-Full"><a href="#gt-gt-gt-FB-Full" class="headerlink" title="&gt;&gt;&gt; FB Full"></a>&gt;&gt;&gt; FB Full</h4><p>This metric does a rough estimation of how often L1D Fill Buffer unavailability limited additional L1D miss memory access requests to proceed. The higher the metric value, the deeper the memory hierarchy level the misses are satisfied from. Often it hints on approaching bandwidth limits (to L2 cache, L3 cache or external memory).</p><h3 id="gt-gt-L2-Bound"><a href="#gt-gt-L2-Bound" class="headerlink" title="&gt;&gt; L2 Bound"></a>&gt;&gt; L2 Bound</h3><p>This metric shows how often machine was stalled on L2 cache. Avoiding cache misses (L1 misses/L2 hits) will improve the latency and increase performance.</p><h3 id="gt-gt-L3-Bound"><a href="#gt-gt-L3-Bound" class="headerlink" title="&gt;&gt; L3 Bound"></a>&gt;&gt; L3 Bound</h3><p>This metric shows how often CPU was stalled on L3 cache, or contended with a sibling Core. Avoiding cache misses (L2 misses/L3 hits) improves the latency and increases performance.</p><h4 id="gt-gt-gt-Contested-Accesses"><a href="#gt-gt-gt-Contested-Accesses" class="headerlink" title="&gt;&gt;&gt; Contested Accesses"></a>&gt;&gt;&gt; Contested Accesses</h4><p>Contested accesses occur when data written by one thread is read by another thread on a different core. Examples of contested accesses include synchronizations such as locks, true data sharing such as modified locked variables, and false sharing. This metric is a ratio of cycles generated while the caching system was handling contested accesses to all cycles.</p><h4 id="gt-gt-gt-Data-Sharing"><a href="#gt-gt-gt-Data-Sharing" class="headerlink" title="&gt;&gt;&gt; Data Sharing"></a>&gt;&gt;&gt; Data Sharing</h4><p>Data shared by multiple threads (even just read shared) may cause increased access latency due to cache coherency. This metric measures the impact of that coherency. Excessive data sharing can drastically harm multithreaded performance. This metric is defined by the ratio of cycles while the caching system is handling shared data to all cycles. It does not measure waits due to contention on a variable, which is measured by the Locks and Waits analysis.</p><h4 id="gt-gt-gt-L3-Latency"><a href="#gt-gt-gt-L3-Latency" class="headerlink" title="&gt;&gt;&gt; L3 Latency"></a>&gt;&gt;&gt; L3 Latency</h4><p>This metric shows a fraction of cycles with demand load accesses that hit the L3 cache under unloaded scenarios (possibly L3 latency limited). Avoiding private cache misses (i.e. L2 misses/L3 hits) will improve the latency, reduce contention with sibling physical cores and increase performance. Note the value of this node may overlap with its siblings.</p><h4 id="gt-gt-gt-SQ-Full"><a href="#gt-gt-gt-SQ-Full" class="headerlink" title="&gt;&gt;&gt; SQ Full"></a>&gt;&gt;&gt; SQ Full</h4><p>This metric measures fraction of cycles where the Super Queue (SQ) was full taking into account all request-types and both hardware SMT threads. The Super Queue is used for requests to access the L2 cache or to go out to the Uncore.</p><h3 id="gt-gt-DRAM-Bound"><a href="#gt-gt-DRAM-Bound" class="headerlink" title="&gt;&gt; DRAM Bound"></a>&gt;&gt; DRAM Bound</h3><p>This metric shows how often CPU was stalled on the main memory (DRAM). Caching typically improves the latency and increases performance.</p><h4 id="gt-gt-gt-Memory-Bandwidth"><a href="#gt-gt-gt-Memory-Bandwidth" class="headerlink" title="&gt;&gt;&gt; Memory Bandwidth"></a>&gt;&gt;&gt; Memory Bandwidth</h4><p>This metric represents a fraction of cycles during which an application could be stalled due to approaching bandwidth limits of the main memory (DRAM). This metric does not aggregate requests from other threads/cores/sockets (see Uncore counters for that). Consider improving data locality in NUMA multi-socket systems.</p><h4 id="gt-gt-gt-Memory-Latency"><a href="#gt-gt-gt-Memory-Latency" class="headerlink" title="&gt;&gt;&gt; Memory Latency"></a>&gt;&gt;&gt; Memory Latency</h4><p>This metric represents a fraction of cycles during which an application could be stalled due to the latency of the main memory (DRAM). This metric does not aggregate requests from other threads/cores/sockets (see Uncore counters for that). Consider optimizing data layout or using Software Prefetches (through the compiler).</p><p><strong>LLC Miss: </strong>The LLC (last-level cache) is the last, and longest-latency, level in the memory hierarchy before main memory (DRAM). Any memory requests missing here must be serviced by local or remote DRAM, with significant latency. The LLC Miss metric shows a ratio of cycles with outstanding LLC misses to all cycles.</p><h3 id="gt-gt-Store-Bound"><a href="#gt-gt-Store-Bound" class="headerlink" title="&gt;&gt; Store Bound"></a>&gt;&gt; Store Bound</h3><p>This metric shows how often CPU was stalled on store operations. Even though memory store accesses do not typically stall out-of-order CPUs; there are few cases where stores can lead to actual stalls. Consider False Sharing analysis as your next step.</p><h4 id="gt-gt-gt-Store-Latency"><a href="#gt-gt-gt-Store-Latency" class="headerlink" title="&gt;&gt;&gt; Store Latency"></a>&gt;&gt;&gt; Store Latency</h4><p>This metric represents cycles fraction the CPU spent handling long-latency store misses (missing 2nd level cache). Consider avoiding/reducing unnecessary (or easily loadable/computable) memory store. Note that this metric value may be highlighted due to a Lock Latency issue.</p><h4 id="gt-gt-gt-False-Sharing"><a href="#gt-gt-gt-False-Sharing" class="headerlink" title="&gt;&gt;&gt; False Sharing"></a>&gt;&gt;&gt; False Sharing</h4><p>This metric shows how often CPU was stalled on store operations to a shared cache line. It can be easily avoided by padding to make threads access different lines.</p><h4 id="gt-gt-gt-Split-Stores"><a href="#gt-gt-gt-Split-Stores" class="headerlink" title="&gt;&gt;&gt; Split Stores"></a>&gt;&gt;&gt; Split Stores</h4><p>This metric represents a rate of split store accesses. Consider aligning your data to the 64-byte cache line granularity.</p><h4 id="gt-gt-gt-DTLB-Store-Overhead"><a href="#gt-gt-gt-DTLB-Store-Overhead" class="headerlink" title="&gt;&gt;&gt; DTLB Store Overhead"></a>&gt;&gt;&gt; DTLB Store Overhead</h4><p>This metric represents a fraction of cycles spent on handling first-level data TLB store misses. As with ordinary data caching, focus on improving data locality and reducing working-set size to reduce DTLB overhead. Additionally, consider using profile-guided optimization (PGO) to collocate frequently-used data on the same page. Try using larger page sizes for large amounts of frequently-used data.</p><h2 id="gt-Core-Bound"><a href="#gt-Core-Bound" class="headerlink" title="&gt; Core Bound"></a>&gt; Core Bound</h2><p>This metric represents how much Core non-memory issues were of a bottleneck. Shortage in hardware compute resources, or dependencies software’s instructions are both categorized under Core Bound. Hence it may indicate the machine ran out of an OOO resources, certain execution units are overloaded or dependencies in program’s data- or instruction- flow are limiting the performance (e.g. FP-chained long-latency arithmetic operations).</p><h3 id="gt-gt-Divider"><a href="#gt-gt-Divider" class="headerlink" title="&gt;&gt; Divider"></a>&gt;&gt; Divider</h3><p>Not all arithmetic operations take the same amount of time. Divides and square roots, both performed by the DIV unit, take considerably longer than integer or floating point addition, subtraction, or multiplication. This metric represents cycles fraction where the Divider unit was active.</p><h3 id="gt-gt-Port-Utilization"><a href="#gt-gt-Port-Utilization" class="headerlink" title="&gt;&gt; Port Utilization"></a>&gt;&gt; Port Utilization</h3><p>This metric represents a fraction of cycles during which an application was stalled due to Core non-divider-related issues. For example, heavy data-dependency between nearby instructions, or a sequence of instructions that overloads specific ports. Hint: Loop Vectorization - most compilers feature auto-Vectorization options today - reduces pressure on the execution ports as multiple elements are calculated with same uOp.</p><h1 id="Retiring"><a href="#Retiring" class="headerlink" title="Retiring"></a>Retiring</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Economics in One Lesson]]></title>
      <url>http://hamstersi.github.io/2017/02/Economics-in-One-Lesson/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><h1 id="关于这堂课"><a href="#关于这堂课" class="headerlink" title="关于这堂课"></a>关于这堂课</h1><p>经济学的艺术，在于不仅要观察任何行为或整车的即期影响，更要考察比较长远的影响；不仅要关注政策对某个群体产生的影响，更要追踪对所有群体造成的影响。</p><h1 id="课程的应用"><a href="#课程的应用" class="headerlink" title="课程的应用"></a>课程的应用</h1><h2 id="gt-破橱窗"><a href="#gt-破橱窗" class="headerlink" title="&gt; 破橱窗"></a>&gt; 破橱窗</h2><p>话说一个顽童抡起砖头，砸破了面包店的橱窗。当店主怒气冲冲追出来时，小捣蛋早已逃之夭夭，只剩下一群看闹热的围观者。大家盯着橱窗的破洞以及四下散落的玻璃碎片，有些人开始互相议论，宽慰店主：玻璃破了很是可惜，可是这也有好的一面。这不，对面的玻璃店又有生意了。他们越琢磨越来劲：一面新的橱窗需要250美元。玻璃店多了250美元，会去别的商家那里消费，那些个商家的口袋里多了几个钱，又会向更多的商家买东西。经这么一说，小小一片破橱窗，竟能够连环不断提供资金给很多商家，使很多人获得就业机会。要是照这个逻辑推下去，结论便是：扔砖头的那个小捣蛋，不但不是社区的祸害，反而是造福社区的善人。</p><a id="more"></a><p>但是，面包店主损失掉的250美元，原本是打算拿去做一套西装的。如今，这钱被迫挪去补破窗。他原来在准备去做西装的那个下午，他本来可以心满意足同时拥有橱窗和西装，结果却只能面对有了橱窗就没了西装的糟糕现实。简单来说，玻璃店主的这桩生意，不过是从做西装的缝纫店主那里转移来的。整个过程并没有新增“就业机会”。那些围观的人只想到了交易双方：面包店主和玻璃店主的情况，却忘掉了可能涉及的第三方缝纫店主的窘迫。</p><h2 id="gt-战祸之福"><a href="#gt-战祸之福" class="headerlink" title="&gt; 战祸之福"></a>&gt; 战祸之福</h2><p>有些人不屑于谈小小的破坏行为带来的蝇头小利，却醉心于巨大的破坏行为能让人们受益无穷。他们吹嘘战争对经济是如何如何的有利，非和平时期能比，并向我们展示通过战争才能实现的“生产奇迹”。他们认为，战争时期庞大的需求“累积”或“堵塞”，会给战后的世界带来繁荣。</p><p>这种“需求堵塞”谬论只不过是我们所熟悉的老朋友——破窗谬论——换上一件臃肿的马甲之后的形象而已。不过这一次，有更多相关的谬误绞缠在一起，需要我们逐一驳斥。首先，它把需要(need)和需求(demand)混为一谈。战火摧毁的东西越多，人民生活越贫困，战后需要的东西也就越多，这点毋庸置疑。但是，需要并不等于需求。有效的经济需求，光有需要还不算，还必须要有相当的购买力才行。当今印度对产品的实际需要远高于美国，但是它的购买力，以及由此带来的创造商机的能力却远低于美国。</p><p>人们只习惯于用金钱来衡量自己的财富和收入，所以只要手头多了几张钞票，便以为自己过得更好，尽管拿这些钱能买到的东西比从前少，自己实际拥有的东西可能不如从前。人们所认为的第二次世界大战带来的经济“收益”，其实大多是战时通货膨胀造成的幻象。哪怕在和平年代，同等规模的通货膨胀也能带来这样的结果，并且的确产生过这些结果。</p><p>那些认为战争造成的破坏能增加总体“需求”的人，还遗漏了一个基本事实：需求和供给就像硬币的两面，其实是从不同角度观察到的同一样东西。供给会创造需求，因为归根结底供给就是需求。人们把自己生产的东西供应给他人，其实是为了换得自己想要的东西。农民为城市供应小麦，是因为他们需要汽车或其他产品。所有这些，是现代分工和交换经济的本质。</p><h2 id="gt-公共工程来自缴税"><a href="#gt-公共工程来自缴税" class="headerlink" title="&gt; 公共工程来自缴税"></a>&gt; 公共工程来自缴税</h2><p>我们必须认识到：政府所有的支出最后都必须靠纳税人来埋单；通货膨胀本身只是税收的一种表现形式，并且是极其有害的形式。</p><p>一定数额的公共开支对执行基本的政府职能是必要的。一定数量的公共设施建设，如街道、桥梁、隧道、军营、海军基地、议会大厦、警察局和消防队，是提供基本的公共服务所必需的。社会对这些公共建设本身有需要，需要就是其存在的理由。但如果是为了“提高就业机会”而建桥，那就成另外一回事了。当提供就业机会成了目的之后，有无兴建桥梁的实际需要就会成为次要问题。这时，政府必须无中生有，发明各种“公共建设计划”。他们不再只考虑哪里必须建桥，而是开始自问自答：桥可以建在哪里。</p><p>不难发现，造桥工程不过是使就业机会发生了转移而已。造桥工程每制造一个用于公共建设上的工作机会，就必定会破坏掉一个用于私人领域的工作机会。我们看得见桥梁工地上建设者们夜以继日，但有些东西我们是看不到的。这些看不到的东西，是从纳税人的口袋拿走1000万美元之后而破坏掉的工作机会，一方面造桥工人在增加，另一方面汽车工人、电视机工人、制衣工人、农民在越少。</p><h2 id="gt-税负抑制生产"><a href="#gt-税负抑制生产" class="headerlink" title="&gt; 税负抑制生产"></a>&gt; 税负抑制生产</h2><p>我们都知道，在现代社会中，每个人所承受的所得税比例不尽相同。为了弥补公共开支，政府还必须开征其他名目繁多的赋税，从而进一步挫伤了生产者的积极性。没有人情愿自己的钱被政府拿走，税负不可避免地会影响纳税人的行为和动机。如果一家公司发生亏损，每赔一块钱，就得足足损失一块钱；要是没有适当的税务会计法规，允许拿数年来的亏损去冲抵数年来的利润的话，当这家公司赚钱的时候，每赚一块钱，却只能留下税后的部分(例如52美分)。于是，公司的经营政策就会受到影响，它将丧失扩张业务的冲动，或者只扩张那些风险最低的业务。觉察到这种状况的人甚至会打消开创新事业的念头。现有的雇主将不再增加员工，甚至会设法减员；其他人则根本不打算成为雇主。长期下来，与本来可以达到的水准相比，新设备和新工艺的应用放慢，消费者买不到更好更便宜的产品，实际工资不升反降。</p><h2 id="gt-政府信贷扭曲生产"><a href="#gt-政府信贷扭曲生产" class="headerlink" title="&gt; 政府信贷扭曲生产"></a>&gt; 政府信贷扭曲生产</h2><p>有时，政府拿钱出来“扶持”企业，这其实和政府征敛民财一样可怕。扶持的形式通常表现为政府直接贷款，以及政府担保的民间贷款等。</p><p>私人提供贷款与政府提供贷款这二者有根本的不同。每个私营放贷者都是在用自己的资金承担风险。银行家虽然是利用别人委托给他的钱去冒险，但一旦有损失，也必须拿自己的钱去赔付，否则只有破产出局。当人们拿自己的钱去冒险时，通常会严格审查借款人是否有足够的资产做抵押，审查其经营能力和诚信如何。</p><p>倘若政府依照同样严格的标准去办理贷款业务，那政府根本没有必要涉足这一行，去做私营机构已经在做的事。政府之所以涉足贷款业，就是要向那些从私营机构借不到钱的人提供资金。换句话说，私营放贷者不肯拿自己的钱去冒的风险，政府却愿意拿纳税人的钱去冒险。这种措施的支持者也承认政府放贷的坏帐率高于民间放贷，但他们坚持认为，那些有借有还的人所增加的产出，加上大部分有借无还的人所增加的产出，在抵消坏账损失后仍有剩余。</p><p>政府贷款的一种后果：浪费资本和削弱生产。政府信贷会把可用的资本丢进糟糕的计划中，充其量也是丢进好坏难断的计划中。政府信贷更可能把资本交给能力比较差、或者比较不可靠的人。可是在任何时候，实体资本的数量都是有限的(有别于靠印钞机印出来的货币资本)，交到某乙手中的东西，就不可能再交给某甲。</p><h2 id="gt-诅咒机器"><a href="#gt-诅咒机器" class="headerlink" title="&gt; 诅咒机器"></a>&gt; 诅咒机器</h2><p>在所有的经济错觉中，“机器必然导致失业”这种错误最为阴魂不散。这种错觉曾经被无数人驳倒过，但总能死灰复燃，并且和以往一样张狂。</p><p>如果采用省力机器确实会造成失业率不断上升、加剧不幸的话，我们将合乎逻辑地得出颠覆性的结论，不仅会颠覆技术领域的观念，而且会颠覆整个人类文明的观念。我们不仅应该把任何的新技术进步都视为一场灾难，而且更该觉得过去所有的技术进步也都同样恐怖。大大小小的雇主，总在设法通过节约劳动力来提高经济效益。头脑灵活的工人，都会想办法以最少的付出去完成上面指派的工作。雄心勃勃的人，总在坚持不懈地跟时间赛跑。如果严守逻辑上的一致性，那么恐惧科技进步的人必须摒弃所有这些进步和智巧，因为技术进步不但无益，而且有害。比方说从芝加哥运货到纽约，要是我们能够大量雇用人力，我们何必还要用火车，让人扛起货物背过去得了。</p><p>我们需要重申，机器所带来的是促进生产和提高生活水平。这个结果可以通过两条途径来实现：机器使消费者购买的产品变得更加便宜，或者提高工人的生产力，从而使工人的工资能够提高。换句话说，机器能够提高货币工资，或者能够降低物价，让同样的薪水能买到更多的产品和服务。</p><h2 id="gt-分散工作机会的企图"><a href="#gt-分散工作机会的企图" class="headerlink" title="&gt; 分散工作机会的企图"></a>&gt; 分散工作机会的企图</h2><p>“制造工作机会”和“限产超雇”的这些做法的起因以及公众容忍它们的起因，跟害怕机器的起因一样，都源自相同的基本谬论：用更有效率的方式去做事，只会消减工作机会。这个信条换句话说就是，采用低效率的方式去做一件事，反而可以创造工作机会。和这个谬论有关的另一种论调认为，世界上可做的工作是有限的，要是我们想不出更繁琐拖沓的做事方式来增加工作量，那么我们至少可以想方设法将事情分摊给尽可能多的人去做。</p><p>倘若大家各自为政，少数人的确可以从这种不合理的细部分工规定中获利，然而这种呆板的规定是以牺牲其他人的利益为代价的。支持这类做法的人没有看到生产成本一定会因此增高，从总体上看，最终结果是工作做得更少，生产出的产品更少。</p><h2 id="gt-遣散军队和裁减公务员"><a href="#gt-遣散军队和裁减公务员" class="headerlink" title="&gt; 遣散军队和裁减公务员"></a>&gt; 遣散军队和裁减公务员</h2><p>每逢战争结束，军人复员的时候，人们总是担忧没有足够多的工作岗位来安置这些复员军人，担心这些人会失业。但是，军人复员转业之后的经济，与遣散之前的经济不会相同。以前靠平民养活的军人，而今是自食其力的平民。战争结束了，国防建设也用不了那么多军人，继续把他们留在军中就是徒劳无益的事情，因为纳税人出钱供养他们是得不到相应回报的。现在，纳税人能把这一部分的钱支付给复员转业人员，换取等值的产品或服务。国民生产总值，以及每个人的财富，都会增加更多。同样的推理也适用于政府裁减冗员的情况。由于人浮于事，这些公务员为社会提供的服务配不上他们所获得的薪酬。</p><p>裁掉冗员之后的国家比留用冗员时，不会更糟，只会更好。因为这部分人必须自谋职业或自己创业。纳税人购买力增加，将为被裁公务员提供更多就业机会，这跟军人复员的情形一样。并且，这些人只有为雇主或顾客提供等值服务，才能在社会立足。他们不再是社会的寄生虫，而成为直接为社会贡献生产力的个人。</p><h2 id="gt-盲目崇拜充分就业"><a href="#gt-盲目崇拜充分就业" class="headerlink" title="&gt; 盲目崇拜充分就业"></a>&gt; 盲目崇拜充分就业</h2><p>与每个人的经济目标一样，任何国家的经济目标也应该是用最少的付出获得最大的收益。中国和印度远比美国贫穷，但它们的主要问题也不是失业问题，而是生产方式太落后(这既是资本短缺的原因，也是资本短缺的结果)。</p><p>文明的进步其实体现在就业人口的减少上，而不是体现在增加上。这是因为当国家变得日益富裕之后，我们得以禁止使用童工，得以实现老有所养。只要我们把重点放在该放的地方，也就是采取生产最大化的政策，我们就不会迷失。</p><h2 id="gt-关税“保护”了哪些人？"><a href="#gt-关税“保护”了哪些人？" class="headerlink" title="&gt; 关税“保护”了哪些人？"></a>&gt; 关税“保护”了哪些人？</h2><p>关税常被看作是以牺牲消费者来造福生产者的一种手段。从某种意义上讲，这话大致不错。那些主张征收关税的人，只考虑到受关税保护的生产者能立即获得利益，却忽略被迫支付关税的消费者会立即遭受损失。但把关税只看成是生产者利益与消费者利益之间的冲突，却是不对的。关税的确让所有的消费者蒙受损失，但并非所有的生产者都从中获益。前面谈过，关税只对受保护的生产者有帮助，为此不惜牺牲其他所有的美国生产者：尤其是对那些出口潜力相对较大的生产者利益的损害。</p><h2 id="gt-拼命出口"><a href="#gt-拼命出口" class="headerlink" title="&gt; 拼命出口"></a>&gt; 拼命出口</h2><p>长期而言，进口与出口必然相等(这里的进出口指“国际收支账户”里的所有项目，包括“无形”项目，如旅游消费、海运费用等)。有出口，才有钱进口；没有进口，就没有机会出口，因为外国人没有美元可以用来买美国的产品。要想扩大出口，就必须有更多的进口，否则收不到货款。要想压缩进口，出口也会随之被压缩。</p><h2 id="gt-“平准价格”"><a href="#gt-“平准价格”" class="headerlink" title="&gt; “平准价格”"></a>&gt; “平准价格”</h2><p>平准价格的说法大致如下。在所有产业中，农业最基本、最重要，必须不惜一切代价加以保护。还说，只有农民富裕了，其他人的富裕才有着落。要是农民缺乏购买力，买不起工业产品，工商业就会萎缩。</p><p>政府干预并没有停留在造成购买力的转移，也就是把购买力从城市消费者(或一般纳税人，或两者兼而有之)，转移到农民手上。政府干预往往通过限制农产品的生产以抬高价格，这样会造成财富灭失，因为可供消费农产品被人为减少了。</p><h2 id="gt-救救X产业"><a href="#gt-救救X产业" class="headerlink" title="&gt; 救救X产业"></a>&gt; 救救X产业</h2><p>拯救X产业的办法不胜枚举。相关提案大抵有两大类。其中一类强调，X产业已经“过度拥挤”，政府应该阻止其他公司或劳工再进入。另一类则呼吁，政府应该以直接补贴的方式对X产业给予扶持。</p><p>如果X产业与其他产业相比确实过度拥挤，那根本不需要任何强制立法，去排斥新资本或新劳工进入。新资本不会抢着挤进显然要垮掉的行业。投资人不会冒然踏进风险最大、回报率最低的行业。劳工如果能更好的选择，同样不会进入工资最低、工作最不稳定的行业。如果新资本和新劳工是被强制排斥在X产业之外，例如垄断、同业联盟、工会的政策或者法律等强制手段剥夺了这些资源的自由选择。投资人只好将钱投向回报率还不如X产业的其他地方。其结果是产量减少，进而导致生活水平普遍下降。</p><p>从国库直接拿钱来补贴X产业，这只不过是将财富或收益转移到X产业。X产业中的人获得多少，纳税人就损失多少。但是，补贴的结果不仅仅是财富或收益的转移，也不仅仅意味其他产业的总体萎缩程度和X产业的扩张程度相当。</p><h2 id="gt-价格体系如何运作？"><a href="#gt-价格体系如何运作？" class="headerlink" title="&gt; 价格体系如何运作？"></a>&gt; 价格体系如何运作？</h2><p>在现代这样一个错综复杂的社会中，人们的需要和要求及其轻重缓急千差万别，如何解决劳力和资本用在哪里的问题？解决之道正是通过价格体系，也就是通过生产成本、价格和利润三者间不断变动的交互关系来调节的。</p><p>生产成本决定价格这样的理论是不对的。价格取决于供给和需求，而需求取决于人们想要拥有某种商品渴求程度，以及由人们用来交换的东西所决定。认为供给有一部分取决于生产成本是对的。但一种商品已经发生的生产成本却不能决定商品的价值。商品价值取决于现在发生的供需关系。对于一种商品未来生产成本和市场价位的预期，将会决定<br>那种商品未来的生产数量，这种预期就会影响未来的供给。因此，一种商品的价格与其边际生产成本总是趋于彼此相等，但并不是由于边际生产成本直接决定价格。</p><p>经济处于均衡状态时，某个行业的扩张，必然要以其他行业牺牲为代价。生产要素在任何时候都是有限的。只有当劳工、土地和资本，从原来的行业转移到了某个行业，那个行业才能够扩张。当某一行业萎缩或者停止增产，并不必然意味着总体生产出现净减少。因为该行业萎缩所释放出劳工和资本，可供其他的行业用于扩张。简单地说，生产每一样东西，都得以牺牲放弃其他某样东西为代价。</p><h2 id="gt-“稳定”物价"><a href="#gt-“稳定”物价" class="headerlink" title="&gt; “稳定”物价"></a>&gt; “稳定”物价</h2><p>在自由竞争的市场经济中，由于价格下跌而被逐出市场的，都是高成本、低效率的生产者。政府一刀切限制生产的结果，意味着效率高、成本低的生产者不准以低价供应其全部产量，同时意味着效率低、成本高的生产者仍将被人为地保留在业内。这就使得产品的平均生产成本提高，生产效率下降。因为土地、人力和资本这些资源被无效率的边际生产者继续占用，就无法转移到收益和效率更高的地方。</p><p>政府规划官员在这里所说的自由贸易到底是什么意思，我弄不清楚，但是他们的言下之意不包含哪些事情，我们倒是相当确定。他们的意思绝对不是说，平民百姓可以自由地从事买卖或者借贷，自由谈判价格或利率，自由出入他们觉得收益最大的地方。他们的意思绝对不是说，平民百姓可以自主决定产量、可以自由移民、可以自由支配自己的资本和财物。我怀疑他们的意思是说，由官僚来替平民百姓决定这些事情，并且告诉平民，服从计划奖赏将是生活水平的提高。</p><h2 id="gt-政府管制价格"><a href="#gt-政府管制价格" class="headerlink" title="&gt; 政府管制价格"></a>&gt; 政府管制价格</h2><p>当商品价格被人为限制在它的市场价位之下时，不可避免地会带来两个结果。第一是导致受控商品的需求增加。由于该商品变得便宜，图便宜的人会更多，人们也买得起更多。第二是导致受控商品供给减少。由于人们买得更多，该商品势必供不应求。但是生产积极性却遭到打击，降价致使该商品收益率降低，甚至做不出利润。边际生产者被迫出局。即使最有效率的生产者也可能亏本经营。</p><p>价格上涨的真正原因，是商品匮乏或货币过剩。法定价格上限根本无法解决这两方面的问题。事实上，这只会加剧商品短缺。人们当然不想花更多的钱去购买牛奶、黄油、鞋子、家具、戏票、钻石，去支付房租。对于每个人来说，惟一该涨价的，是他自己生产的东西；这是一个人理解并赞成价格上涨的原因。不过，人人都觉得自己的产品才应该最应该涨价。</p><p>我们每个人都具备多重经济角色。每个人都是生产者、纳税人，消费者。作为生产者时，他希望涨价(因为顾及自己的服务或产品)；作为消费者时，他希望降价(因为顾及自己的钱口袋)。作为消费者，他可能主张或者默许政府实施补贴；作为纳税人，他反对政府实施补贴。每个人都心照不宣想从各种政治力量的斗争中获利，例如让自己产品涨价而不让原材料涨价，或者作为消费者支持价格管制。</p><h2 id="gt-房租管制的后果"><a href="#gt-房租管制的后果" class="headerlink" title="&gt; 房租管制的后果"></a>&gt; 房租管制的后果</h2><p>不合理的价格管制施加在面包等日用消费品上的时候，面包店只要停止烘焙、停止出售面包就行。面包马上就会供不应求，迫使政治人物提高价格上限，甚至取消价格管制。房租管制则有所不同。一方面，房东除了继续把房子租出去，通常没有别的选择，因为在扣除税金和抵押贷款利息之后总还有点净收入，尽管无力维修。另一方面，由于房屋经久耐用，可能要住上好几年，租户才会开始感受到房东无力维修的苦果。也许再过数年，人们才会意识到房荒与房屋设施恶化，与房租管制有直接的关系。在普通价格管制取消多年之后，房租管制仍在继续，因为政治人物知道租户的票数比房东的票数更多。</p><p>房租管制迟迟不能取消，其压力来自于只顾某个群体短期利益的那些人。如果我们考虑每个人(包括租户本身)受到的长期影响，我们就会认识到房租管制徒劳无益，就会认识到管制手段越严厉、实施时间越长，它的破坏性越大。</p><h2 id="gt-最低工资法"><a href="#gt-最低工资法" class="headerlink" title="&gt; 最低工资法"></a>&gt; 最低工资法</h2><p>我们已经看到政府以行政干预提高某些商品的价格所带来的破坏作用。通过法律规定最低工资标准来提高工资，也会造成类似的破坏。这不足为奇，因为工资其实就是劳工提供服务的价格。很不幸，这种价格竟然取了个与其他的价格迥然不同的名称，这会让人思维不清楚。</p><p>最低工资法的出发点是要消灭低工资，但事实表明，这样的法律不但在保护劳工方面效果有限，而且弊大于利的程度和其目标成正比。提高工资的最佳手段，是提高边际劳工的生产力。这可以通过许多方法来实现：通过增加资本累积，例如添置机器以协助劳工；通过引进新的发明和改进；通过提高管理效率；通过激励更加勤奋和更有效劳作；通过更好的教育培训等。</p><h2 id="gt-工会真的有办法提高工资吗？"><a href="#gt-工会真的有办法提高工资吗？" class="headerlink" title="&gt; 工会真的有办法提高工资吗？"></a>&gt; 工会真的有办法提高工资吗？</h2><p>工会会员不是慈善家和圣人，靠工资吃饭的劳工也不是。我们都渴望获得经济公平，但这种所谓的公平其实是，渴望自己拥有东西与比自己过得好的人一样多，而不希望比自己过得差的人拥有与自己一样多的东西。不过，我们现在不去关心这种人性上的劣根性，我们现在所关心的，是特定经济理论是否合乎逻辑和合理。</p><h2 id="gt-“有足够的钱买回商品”"><a href="#gt-“有足够的钱买回商品”" class="headerlink" title="&gt; “有足够的钱买回商品”"></a>&gt; “有足够的钱买回商品”</h2><p>经济均衡(equilibrium)的一般意义和影响的问题上。均衡工资和价格是指使供给和需求均衡时的工资和价格。如果通过政府或私人强行将价格提升到高于它们的均衡水平，需求将下降，从而导致生产萎缩。如果强行将价格压到低于它们的均衡水平，随之而来的利润的下降将意味着供应下降或生产缩减。所以任何迫使价格高于或低于均衡水平(自由市场经常使之趋于这个水平)的企图，都将导致就业量和生产量缩减到低于它们应有的水准。</p><p>价格、工资和利润，能决定产品分配。最好的价格并非最高价格，而是能促进达到最大产量和最大销售量的价格。最好的工资率也不是最高的工资率，而是能达到充分生产、充分就业和持久稳定的最大总工资的工资率。不论从业界还是从劳工的角度来看，最好的利润不是指最低的利润，而是能够鼓励更多人投资、创业，更多人成为雇主，能提供更多就业机会的利润。</p><h2 id="gt-利润的功能"><a href="#gt-利润的功能" class="headerlink" title="&gt; 利润的功能"></a>&gt; 利润的功能</h2><p>利润的一大功能是引导生产要素的流向，依照需求来配置各种商品的相对产出。利润的实现不是靠提高价格，而是靠降低生产成本，靠讲求经济效益和效率。利润来自成本和价格之间的关系，它不仅告诉我们生产何种产品最经济，而且告诉我们哪种生产方式最经济。</p><h2 id="gt-通货膨胀的幻景"><a href="#gt-通货膨胀的幻景" class="headerlink" title="&gt; 通货膨胀的幻景"></a>&gt; 通货膨胀的幻景</h2><p>通货膨胀一旦启动便不受控制。我们不可能引导其平缓温和地结束，我们无法扭转随之而来的经济萧条。甚至不可能在预先设定的时点，或在价格上涨到预先设定的水平而让通货膨胀暂停。靠政治力量和经济力量都无法驾驭通货膨胀。那些能从通货膨胀中获得利益的政治集团，必然坚持继续维持通货膨胀。</p><p>通货膨胀的真正作用是改变价格和成本之间的关系。它所带来的最大改变，是提高相对于工资率的商品价格，借此来恢复价格和生产成本之间可以持续经营的关系，进而能借恢复经营利润来盘活闲置资源，鼓励恢复生产。</p><p>通货膨胀给每一经济过程罩上了一层迷惑人的面纱，欺骗了几乎所有人，包括那些受其害的人。当我们听到，国民收入(以货币计量)比通货膨胀之前增加一倍，谁不会觉得更富有更骄傲呢？原先周薪75美元的小职员，现在能拿120美元，他也会觉得比以前更强。他当然能感觉到生活费用涨得厉害，但是他并没有充分觉察到自己的真实处境。虽然同样是实质购买力降低，他无法接受生活费用不变而工资调减的事实，但是他会欣然接受工资调增而生活费用上涨的事实。通货膨胀有如自我暗示、催眠术、麻醉剂，可以减轻手术时的痛苦。通货膨胀也像鸦片，吸上一口，就觉得自己无所不能。</p><h2 id="gt-抨击储蓄"><a href="#gt-抨击储蓄" class="headerlink" title="&gt; 抨击储蓄"></a>&gt; 抨击储蓄</h2><p>有些被认为是当今杰出经济学家的人，为了避免国家经济萧条，竟然抨击储蓄，鼓吹大肆消费。当有人对这些政策的长期效应提出质疑时，他们却像败家子讥讽父母的忠告那样不屑一顾地说：“何必看得那么远呢？要知道从长远来看，我们都是要死的。”这么一句轻率的戏言，却被人当作至理名言和大智慧，奉为经济生活中的信条。不幸的是，长远并不真的那么远，或远或近的过去实施的政策所带来的长期影响，已经给我们带来煎熬了。坏的经济学家昨天要我们置之不理的明天，转眼就成了今天。总之，现代世界中的“储蓄”，只是支出的另一种形式。两者的差别，通常在于前者把钱交给别人用于扩大生产。</p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[2013 - 11 浮生奥克兰]]></title>
      <url>http://hamstersi.github.io/2017/02/2013-11-%E6%B5%AE%E7%94%9F%E5%A5%A5%E5%85%8B%E5%85%B0/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>和家里和朋友告了别，我是听着这首歌踏入中土世界的。飞机盘旋在奥克兰上空的时候，心里特别感动。大概是被这云层下的异乡与自以为是的勇气给触动了。其实在奥克兰待得真的不算长，不久便迫于生计辗转各个城市，最终在基督城安顿了半年。</p><p>对于基督城的感情，那大概是习惯使然。而对于新西兰来说，最有标志性的还是要数奥克兰和惠灵顿。在码头听海鸥和诗人游唱，在山上看日落看霓虹渐起，望天空塔向跨年烟火许愿，我对陌生人说新年要快乐。那个时候我不曾相问未来，朋友们萍水相逢来来去去换了一批又一批，终究却还是独自上路。</p><a id="more"></a><p>我一直特别想念这中土世界，从未断过的想念，一想到她呀，心里就悸动。那个时候少年轻狂，如今也只是活了个不明不白。让我们再见吧，奥克兰、再见吧，新西兰——</p><div id="aplayer0" class="aplayer" style="margin-bottom:20px;width:99%"></div><script>new APlayer({element:document.getElementById("aplayer0"),narrow:!1,autoplay:!1,showlrc:0,music:{title:"Down by the Salley Gardens",author:"Joanie Madden",url:"http://link.hhtjim.com/xiami/1354490.mp3",pic:"http://wx4.sinaimg.cn/large/672d88aaly9fd34xh7c7kj20ti0ti1kx.jpg"}})</script><p><img src="http://wx2.sinaimg.cn/large/672d88aagy1fcutfciukmj23b4274b29.jpg" alt="Auckland | Ferry Terminal"><br><img src="http://wx3.sinaimg.cn/large/672d88aagy1fcutf5g35wj23b4274hdt.jpg" alt="Auckland | Ferry Terminal"><br><img src="http://wx3.sinaimg.cn/large/672d88aagy1fcuteo3qznj23b4274hbf.jpg" alt="Auckland | Mt. Eden"><br><img src="http://wx4.sinaimg.cn/large/672d88aagy1fcutey4l2vj23b4274hc8.jpg" alt="Auckland | Mt. Eden"><br><img src="http://wx1.sinaimg.cn/large/672d88aagy1fcutfgvtxmj23b42741kx.jpg" alt="Auckland | Sky Tower"><br><img src="http://wx4.sinaimg.cn/large/672d88aagy1fcutfo7pb1j23b4274e81.jpg" alt="Auckland | Sky Tower"></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Porting the Essential Dynamics/Molecular Dynamics method for large-scale nucleic acid simulations to ARCHER]]></title>
      <url>http://hamstersi.github.io/2017/02/Porting-the-Essential-Dynamics-Molecular-Dynamics-method-for-large-scale-nucleic-acid-simulations-to-ARCHER/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><p>The Molecular Dynamics (MD) simulation is an important computer modelling and simulation technique to study the physical behaviours of molecules and atoms. It has been widely applied in various scientific fields, and is of great value to do the MD simulation on biomacromolecules such as proteins and DNA, rendering scientists and researchers a rich source of information about the biological macromolecules.</p><p>The goal of this project was to develop a parallel code to perform the MD simulation on the large-scale nucleic acid DNA systems with a newly proposed method, namely the Essential Dynamics (ED), after reviewing two current existing code versions.<a id="more"></a> The two codes are written in Fortran 95 with MPI and Python respectively. Both codes have implemented the new Essential Dynamics/Molecular Dynamics (ED/MD) simulation for the DNA systems but in a quite primitive mode that contain serious limitations either on the execution flexibility (the Fortran 95/MPI code) or on the performance (the serial Python code). The new code is developed in C++ with MPI, which is a more flexible parallel code version compared to the Fortran 95/MPI code in the aspect of the degree of parallelism, while the performance is significantly improved by contrast with the serial Python code. The new code is compiled and run on ARCHER during the development, but it also has fairly good portability that can be executed on other parallel platforms or in personal laptops.</p><p>The simulation results of the new C++/MPI code are verified according to the results of the Fortran 95/MPI code, and the performance is also analysed afterwards. Due to the new parallelisation strategy that is different from the Fortran 95/MPI code, the improved flexibility of the parallelism is at the expense of some message passing overheads. To reduce the overheads and improve the performance, several parallel schemes have been proposed and implemented. The performance now is quite reasonable and acceptable with less time wasted on the communication. However, the future development work can still be carried on to further improve the execution efficiency of the parallel code.</p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://hamstersi.github.io/2017/02/Hello-World/</url>
      <content type="html"><![CDATA[<script src="/assets/js/APlayer.min.js"> </script><center><br>Hello World! This planet turns so fast, everything burns, ashes to ash, but for now you are mine…<br></center><a id="more"></a>]]></content>
    </entry>
    
  
  
</search>
